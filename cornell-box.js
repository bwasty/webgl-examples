!function(n,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("gloperate"));else if("function"==typeof define&&define.amd)define(["gloperate"],t);else{var e="object"==typeof exports?t(require("gloperate")):t(n.gloperate);for(var r in e)("object"==typeof exports?exports:n)[r]=e[r]}}(window,function(n){return function(n){var t={};function e(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return n[r].call(i.exports,i,i.exports,e),i.l=!0,i.exports}return e.m=n,e.c=t,e.d=function(n,t,r){e.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:r})},e.r=function(n){Object.defineProperty(n,"__esModule",{value:!0})},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},e.p="",e(e.s=46)}({0:function(t,e){t.exports=n},1:function(n,t,e){"use strict";e.r(t);var r={};e.d(r,"EPSILON",function(){return h}),e.d(r,"ARRAY_TYPE",function(){return d}),e.d(r,"RANDOM",function(){return m}),e.d(r,"setMatrixArrayType",function(){return _}),e.d(r,"toRadian",function(){return g}),e.d(r,"equals",function(){return M});var i={};e.d(i,"create",function(){return x}),e.d(i,"clone",function(){return p}),e.d(i,"copy",function(){return I}),e.d(i,"identity",function(){return E}),e.d(i,"fromValues",function(){return b}),e.d(i,"set",function(){return S}),e.d(i,"transpose",function(){return y}),e.d(i,"invert",function(){return w}),e.d(i,"adjoint",function(){return L}),e.d(i,"determinant",function(){return T}),e.d(i,"multiply",function(){return R}),e.d(i,"rotate",function(){return P}),e.d(i,"scale",function(){return N}),e.d(i,"fromRotation",function(){return A}),e.d(i,"fromScaling",function(){return O}),e.d(i,"str",function(){return z}),e.d(i,"frob",function(){return F}),e.d(i,"LDU",function(){return q}),e.d(i,"add",function(){return D}),e.d(i,"subtract",function(){return C}),e.d(i,"exactEquals",function(){return G}),e.d(i,"equals",function(){return H}),e.d(i,"multiplyScalar",function(){return U}),e.d(i,"multiplyScalarAndAdd",function(){return B}),e.d(i,"mul",function(){return Z}),e.d(i,"sub",function(){return V});var o={};e.d(o,"create",function(){return k}),e.d(o,"clone",function(){return Y}),e.d(o,"copy",function(){return j}),e.d(o,"identity",function(){return X}),e.d(o,"fromValues",function(){return W}),e.d(o,"set",function(){return K}),e.d(o,"invert",function(){return Q}),e.d(o,"determinant",function(){return J}),e.d(o,"multiply",function(){return $}),e.d(o,"rotate",function(){return nn}),e.d(o,"scale",function(){return tn}),e.d(o,"translate",function(){return en}),e.d(o,"fromRotation",function(){return rn}),e.d(o,"fromScaling",function(){return on}),e.d(o,"fromTranslation",function(){return an}),e.d(o,"str",function(){return cn}),e.d(o,"frob",function(){return un}),e.d(o,"add",function(){return sn}),e.d(o,"subtract",function(){return ln}),e.d(o,"multiplyScalar",function(){return fn}),e.d(o,"multiplyScalarAndAdd",function(){return hn}),e.d(o,"exactEquals",function(){return dn}),e.d(o,"equals",function(){return mn}),e.d(o,"mul",function(){return _n}),e.d(o,"sub",function(){return vn});var a={};e.d(a,"create",function(){return gn}),e.d(a,"fromMat4",function(){return Mn}),e.d(a,"clone",function(){return xn}),e.d(a,"copy",function(){return pn}),e.d(a,"fromValues",function(){return In}),e.d(a,"set",function(){return En}),e.d(a,"identity",function(){return bn}),e.d(a,"transpose",function(){return Sn}),e.d(a,"invert",function(){return yn}),e.d(a,"adjoint",function(){return wn}),e.d(a,"determinant",function(){return Ln}),e.d(a,"multiply",function(){return Tn}),e.d(a,"translate",function(){return Rn}),e.d(a,"rotate",function(){return Pn}),e.d(a,"scale",function(){return Nn}),e.d(a,"fromTranslation",function(){return An}),e.d(a,"fromRotation",function(){return On}),e.d(a,"fromScaling",function(){return zn}),e.d(a,"fromMat2d",function(){return Fn}),e.d(a,"fromQuat",function(){return qn}),e.d(a,"normalFromMat4",function(){return Dn}),e.d(a,"projection",function(){return Cn}),e.d(a,"str",function(){return Gn}),e.d(a,"frob",function(){return Hn}),e.d(a,"add",function(){return Un}),e.d(a,"subtract",function(){return Bn}),e.d(a,"multiplyScalar",function(){return Zn}),e.d(a,"multiplyScalarAndAdd",function(){return Vn}),e.d(a,"exactEquals",function(){return kn}),e.d(a,"equals",function(){return Yn}),e.d(a,"mul",function(){return jn}),e.d(a,"sub",function(){return Xn});var c={};e.d(c,"create",function(){return Wn}),e.d(c,"clone",function(){return Kn}),e.d(c,"copy",function(){return Qn}),e.d(c,"fromValues",function(){return Jn}),e.d(c,"set",function(){return $n}),e.d(c,"identity",function(){return nt}),e.d(c,"transpose",function(){return tt}),e.d(c,"invert",function(){return et}),e.d(c,"adjoint",function(){return rt}),e.d(c,"determinant",function(){return it}),e.d(c,"multiply",function(){return ot}),e.d(c,"translate",function(){return at}),e.d(c,"scale",function(){return ct}),e.d(c,"rotate",function(){return ut}),e.d(c,"rotateX",function(){return st}),e.d(c,"rotateY",function(){return lt}),e.d(c,"rotateZ",function(){return ft}),e.d(c,"fromTranslation",function(){return ht}),e.d(c,"fromScaling",function(){return dt}),e.d(c,"fromRotation",function(){return mt}),e.d(c,"fromXRotation",function(){return _t}),e.d(c,"fromYRotation",function(){return vt}),e.d(c,"fromZRotation",function(){return gt}),e.d(c,"fromRotationTranslation",function(){return Mt}),e.d(c,"getTranslation",function(){return xt}),e.d(c,"getScaling",function(){return pt}),e.d(c,"getRotation",function(){return It}),e.d(c,"fromRotationTranslationScale",function(){return Et}),e.d(c,"fromRotationTranslationScaleOrigin",function(){return bt}),e.d(c,"fromQuat",function(){return St}),e.d(c,"frustum",function(){return yt}),e.d(c,"perspective",function(){return wt}),e.d(c,"perspectiveFromFieldOfView",function(){return Lt}),e.d(c,"ortho",function(){return Tt}),e.d(c,"lookAt",function(){return Rt}),e.d(c,"targetTo",function(){return Pt}),e.d(c,"str",function(){return Nt}),e.d(c,"frob",function(){return At}),e.d(c,"add",function(){return Ot}),e.d(c,"subtract",function(){return zt}),e.d(c,"multiplyScalar",function(){return Ft}),e.d(c,"multiplyScalarAndAdd",function(){return qt}),e.d(c,"exactEquals",function(){return Dt}),e.d(c,"equals",function(){return Ct}),e.d(c,"mul",function(){return Gt}),e.d(c,"sub",function(){return Ht});var u={};e.d(u,"create",function(){return Ut}),e.d(u,"clone",function(){return Bt}),e.d(u,"length",function(){return Zt}),e.d(u,"fromValues",function(){return Vt}),e.d(u,"copy",function(){return kt}),e.d(u,"set",function(){return Yt}),e.d(u,"add",function(){return jt}),e.d(u,"subtract",function(){return Xt}),e.d(u,"multiply",function(){return Wt}),e.d(u,"divide",function(){return Kt}),e.d(u,"ceil",function(){return Qt}),e.d(u,"floor",function(){return Jt}),e.d(u,"min",function(){return $t}),e.d(u,"max",function(){return ne}),e.d(u,"round",function(){return te}),e.d(u,"scale",function(){return ee}),e.d(u,"scaleAndAdd",function(){return re}),e.d(u,"distance",function(){return ie}),e.d(u,"squaredDistance",function(){return oe}),e.d(u,"squaredLength",function(){return ae}),e.d(u,"negate",function(){return ce}),e.d(u,"inverse",function(){return ue}),e.d(u,"normalize",function(){return se}),e.d(u,"dot",function(){return le}),e.d(u,"cross",function(){return fe}),e.d(u,"lerp",function(){return he}),e.d(u,"hermite",function(){return de}),e.d(u,"bezier",function(){return me}),e.d(u,"random",function(){return _e}),e.d(u,"transformMat4",function(){return ve}),e.d(u,"transformMat3",function(){return ge}),e.d(u,"transformQuat",function(){return Me}),e.d(u,"rotateX",function(){return xe}),e.d(u,"rotateY",function(){return pe}),e.d(u,"rotateZ",function(){return Ie}),e.d(u,"angle",function(){return Ee}),e.d(u,"str",function(){return be}),e.d(u,"exactEquals",function(){return Se}),e.d(u,"equals",function(){return ye}),e.d(u,"sub",function(){return we}),e.d(u,"mul",function(){return Le}),e.d(u,"div",function(){return Te}),e.d(u,"dist",function(){return Re}),e.d(u,"sqrDist",function(){return Pe}),e.d(u,"len",function(){return Ne}),e.d(u,"sqrLen",function(){return Ae}),e.d(u,"forEach",function(){return Oe});var s={};e.d(s,"create",function(){return ze}),e.d(s,"clone",function(){return Fe}),e.d(s,"fromValues",function(){return qe}),e.d(s,"copy",function(){return De}),e.d(s,"set",function(){return Ce}),e.d(s,"add",function(){return Ge}),e.d(s,"subtract",function(){return He}),e.d(s,"multiply",function(){return Ue}),e.d(s,"divide",function(){return Be}),e.d(s,"ceil",function(){return Ze}),e.d(s,"floor",function(){return Ve}),e.d(s,"min",function(){return ke}),e.d(s,"max",function(){return Ye}),e.d(s,"round",function(){return je}),e.d(s,"scale",function(){return Xe}),e.d(s,"scaleAndAdd",function(){return We}),e.d(s,"distance",function(){return Ke}),e.d(s,"squaredDistance",function(){return Qe}),e.d(s,"length",function(){return Je}),e.d(s,"squaredLength",function(){return $e}),e.d(s,"negate",function(){return nr}),e.d(s,"inverse",function(){return tr}),e.d(s,"normalize",function(){return er}),e.d(s,"dot",function(){return rr}),e.d(s,"lerp",function(){return ir}),e.d(s,"random",function(){return or}),e.d(s,"transformMat4",function(){return ar}),e.d(s,"transformQuat",function(){return cr}),e.d(s,"str",function(){return ur}),e.d(s,"exactEquals",function(){return sr}),e.d(s,"equals",function(){return lr}),e.d(s,"sub",function(){return fr}),e.d(s,"mul",function(){return hr}),e.d(s,"div",function(){return dr}),e.d(s,"dist",function(){return mr}),e.d(s,"sqrDist",function(){return _r}),e.d(s,"len",function(){return vr}),e.d(s,"sqrLen",function(){return gr}),e.d(s,"forEach",function(){return Mr});var l={};e.d(l,"create",function(){return xr}),e.d(l,"identity",function(){return pr}),e.d(l,"setAxisAngle",function(){return Ir}),e.d(l,"getAxisAngle",function(){return Er}),e.d(l,"multiply",function(){return br}),e.d(l,"rotateX",function(){return Sr}),e.d(l,"rotateY",function(){return yr}),e.d(l,"rotateZ",function(){return wr}),e.d(l,"calculateW",function(){return Lr}),e.d(l,"slerp",function(){return Tr}),e.d(l,"invert",function(){return Rr}),e.d(l,"conjugate",function(){return Pr}),e.d(l,"fromMat3",function(){return Nr}),e.d(l,"fromEuler",function(){return Ar}),e.d(l,"str",function(){return Or}),e.d(l,"clone",function(){return zr}),e.d(l,"fromValues",function(){return Fr}),e.d(l,"copy",function(){return qr}),e.d(l,"set",function(){return Dr}),e.d(l,"add",function(){return Cr}),e.d(l,"mul",function(){return Gr}),e.d(l,"scale",function(){return Hr}),e.d(l,"dot",function(){return Ur}),e.d(l,"lerp",function(){return Br}),e.d(l,"length",function(){return Zr}),e.d(l,"len",function(){return Vr}),e.d(l,"squaredLength",function(){return kr}),e.d(l,"sqrLen",function(){return Yr}),e.d(l,"normalize",function(){return jr}),e.d(l,"exactEquals",function(){return Xr}),e.d(l,"equals",function(){return Wr}),e.d(l,"rotationTo",function(){return Kr}),e.d(l,"sqlerp",function(){return Qr}),e.d(l,"setAxes",function(){return Jr});var f={};e.d(f,"create",function(){return $r}),e.d(f,"clone",function(){return ni}),e.d(f,"fromValues",function(){return ti}),e.d(f,"copy",function(){return ei}),e.d(f,"set",function(){return ri}),e.d(f,"add",function(){return ii}),e.d(f,"subtract",function(){return oi}),e.d(f,"multiply",function(){return ai}),e.d(f,"divide",function(){return ci}),e.d(f,"ceil",function(){return ui}),e.d(f,"floor",function(){return si}),e.d(f,"min",function(){return li}),e.d(f,"max",function(){return fi}),e.d(f,"round",function(){return hi}),e.d(f,"scale",function(){return di}),e.d(f,"scaleAndAdd",function(){return mi}),e.d(f,"distance",function(){return _i}),e.d(f,"squaredDistance",function(){return vi}),e.d(f,"length",function(){return gi}),e.d(f,"squaredLength",function(){return Mi}),e.d(f,"negate",function(){return xi}),e.d(f,"inverse",function(){return pi}),e.d(f,"normalize",function(){return Ii}),e.d(f,"dot",function(){return Ei}),e.d(f,"cross",function(){return bi}),e.d(f,"lerp",function(){return Si}),e.d(f,"random",function(){return yi}),e.d(f,"transformMat2",function(){return wi}),e.d(f,"transformMat2d",function(){return Li}),e.d(f,"transformMat3",function(){return Ti}),e.d(f,"transformMat4",function(){return Ri}),e.d(f,"str",function(){return Pi}),e.d(f,"exactEquals",function(){return Ni}),e.d(f,"equals",function(){return Ai}),e.d(f,"len",function(){return Oi}),e.d(f,"sub",function(){return zi}),e.d(f,"mul",function(){return Fi}),e.d(f,"div",function(){return qi}),e.d(f,"dist",function(){return Di}),e.d(f,"sqrDist",function(){return Ci}),e.d(f,"sqrLen",function(){return Gi}),e.d(f,"forEach",function(){return Hi});const h=1e-6;let d="undefined"!=typeof Float32Array?Float32Array:Array;const m=Math.random;function _(n){d=n}const v=Math.PI/180;function g(n){return n*v}function M(n,t){return Math.abs(n-t)<=h*Math.max(1,Math.abs(n),Math.abs(t))}function x(){let n=new d(4);return n[0]=1,n[1]=0,n[2]=0,n[3]=1,n}function p(n){let t=new d(4);return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t}function I(n,t){return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n}function E(n){return n[0]=1,n[1]=0,n[2]=0,n[3]=1,n}function b(n,t,e,r){let i=new d(4);return i[0]=n,i[1]=t,i[2]=e,i[3]=r,i}function S(n,t,e,r,i){return n[0]=t,n[1]=e,n[2]=r,n[3]=i,n}function y(n,t){if(n===t){let e=t[1];n[1]=t[2],n[2]=e}else n[0]=t[0],n[1]=t[2],n[2]=t[1],n[3]=t[3];return n}function w(n,t){let e=t[0],r=t[1],i=t[2],o=t[3],a=e*o-i*r;return a?(a=1/a,n[0]=o*a,n[1]=-r*a,n[2]=-i*a,n[3]=e*a,n):null}function L(n,t){let e=t[0];return n[0]=t[3],n[1]=-t[1],n[2]=-t[2],n[3]=e,n}function T(n){return n[0]*n[3]-n[2]*n[1]}function R(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3],c=e[0],u=e[1],s=e[2],l=e[3];return n[0]=r*c+o*u,n[1]=i*c+a*u,n[2]=r*s+o*l,n[3]=i*s+a*l,n}function P(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3],c=Math.sin(e),u=Math.cos(e);return n[0]=r*u+o*c,n[1]=i*u+a*c,n[2]=r*-c+o*u,n[3]=i*-c+a*u,n}function N(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3],c=e[0],u=e[1];return n[0]=r*c,n[1]=i*c,n[2]=o*u,n[3]=a*u,n}function A(n,t){let e=Math.sin(t),r=Math.cos(t);return n[0]=r,n[1]=e,n[2]=-e,n[3]=r,n}function O(n,t){return n[0]=t[0],n[1]=0,n[2]=0,n[3]=t[1],n}function z(n){return"mat2("+n[0]+", "+n[1]+", "+n[2]+", "+n[3]+")"}function F(n){return Math.sqrt(Math.pow(n[0],2)+Math.pow(n[1],2)+Math.pow(n[2],2)+Math.pow(n[3],2))}function q(n,t,e,r){return n[2]=r[2]/r[0],e[0]=r[0],e[1]=r[1],e[3]=r[3]-n[2]*e[1],[n,t,e]}function D(n,t,e){return n[0]=t[0]+e[0],n[1]=t[1]+e[1],n[2]=t[2]+e[2],n[3]=t[3]+e[3],n}function C(n,t,e){return n[0]=t[0]-e[0],n[1]=t[1]-e[1],n[2]=t[2]-e[2],n[3]=t[3]-e[3],n}function G(n,t){return n[0]===t[0]&&n[1]===t[1]&&n[2]===t[2]&&n[3]===t[3]}function H(n,t){let e=n[0],r=n[1],i=n[2],o=n[3],a=t[0],c=t[1],u=t[2],s=t[3];return Math.abs(e-a)<=h*Math.max(1,Math.abs(e),Math.abs(a))&&Math.abs(r-c)<=h*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(i-u)<=h*Math.max(1,Math.abs(i),Math.abs(u))&&Math.abs(o-s)<=h*Math.max(1,Math.abs(o),Math.abs(s))}function U(n,t,e){return n[0]=t[0]*e,n[1]=t[1]*e,n[2]=t[2]*e,n[3]=t[3]*e,n}function B(n,t,e,r){return n[0]=t[0]+e[0]*r,n[1]=t[1]+e[1]*r,n[2]=t[2]+e[2]*r,n[3]=t[3]+e[3]*r,n}const Z=R,V=C;function k(){let n=new d(6);return n[0]=1,n[1]=0,n[2]=0,n[3]=1,n[4]=0,n[5]=0,n}function Y(n){let t=new d(6);return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t}function j(n,t){return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n}function X(n){return n[0]=1,n[1]=0,n[2]=0,n[3]=1,n[4]=0,n[5]=0,n}function W(n,t,e,r,i,o){let a=new d(6);return a[0]=n,a[1]=t,a[2]=e,a[3]=r,a[4]=i,a[5]=o,a}function K(n,t,e,r,i,o,a){return n[0]=t,n[1]=e,n[2]=r,n[3]=i,n[4]=o,n[5]=a,n}function Q(n,t){let e=t[0],r=t[1],i=t[2],o=t[3],a=t[4],c=t[5],u=e*o-r*i;return u?(u=1/u,n[0]=o*u,n[1]=-r*u,n[2]=-i*u,n[3]=e*u,n[4]=(i*c-o*a)*u,n[5]=(r*a-e*c)*u,n):null}function J(n){return n[0]*n[3]-n[1]*n[2]}function $(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3],c=t[4],u=t[5],s=e[0],l=e[1],f=e[2],h=e[3],d=e[4],m=e[5];return n[0]=r*s+o*l,n[1]=i*s+a*l,n[2]=r*f+o*h,n[3]=i*f+a*h,n[4]=r*d+o*m+c,n[5]=i*d+a*m+u,n}function nn(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3],c=t[4],u=t[5],s=Math.sin(e),l=Math.cos(e);return n[0]=r*l+o*s,n[1]=i*l+a*s,n[2]=r*-s+o*l,n[3]=i*-s+a*l,n[4]=c,n[5]=u,n}function tn(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3],c=t[4],u=t[5],s=e[0],l=e[1];return n[0]=r*s,n[1]=i*s,n[2]=o*l,n[3]=a*l,n[4]=c,n[5]=u,n}function en(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3],c=t[4],u=t[5],s=e[0],l=e[1];return n[0]=r,n[1]=i,n[2]=o,n[3]=a,n[4]=r*s+o*l+c,n[5]=i*s+a*l+u,n}function rn(n,t){let e=Math.sin(t),r=Math.cos(t);return n[0]=r,n[1]=e,n[2]=-e,n[3]=r,n[4]=0,n[5]=0,n}function on(n,t){return n[0]=t[0],n[1]=0,n[2]=0,n[3]=t[1],n[4]=0,n[5]=0,n}function an(n,t){return n[0]=1,n[1]=0,n[2]=0,n[3]=1,n[4]=t[0],n[5]=t[1],n}function cn(n){return"mat2d("+n[0]+", "+n[1]+", "+n[2]+", "+n[3]+", "+n[4]+", "+n[5]+")"}function un(n){return Math.sqrt(Math.pow(n[0],2)+Math.pow(n[1],2)+Math.pow(n[2],2)+Math.pow(n[3],2)+Math.pow(n[4],2)+Math.pow(n[5],2)+1)}function sn(n,t,e){return n[0]=t[0]+e[0],n[1]=t[1]+e[1],n[2]=t[2]+e[2],n[3]=t[3]+e[3],n[4]=t[4]+e[4],n[5]=t[5]+e[5],n}function ln(n,t,e){return n[0]=t[0]-e[0],n[1]=t[1]-e[1],n[2]=t[2]-e[2],n[3]=t[3]-e[3],n[4]=t[4]-e[4],n[5]=t[5]-e[5],n}function fn(n,t,e){return n[0]=t[0]*e,n[1]=t[1]*e,n[2]=t[2]*e,n[3]=t[3]*e,n[4]=t[4]*e,n[5]=t[5]*e,n}function hn(n,t,e,r){return n[0]=t[0]+e[0]*r,n[1]=t[1]+e[1]*r,n[2]=t[2]+e[2]*r,n[3]=t[3]+e[3]*r,n[4]=t[4]+e[4]*r,n[5]=t[5]+e[5]*r,n}function dn(n,t){return n[0]===t[0]&&n[1]===t[1]&&n[2]===t[2]&&n[3]===t[3]&&n[4]===t[4]&&n[5]===t[5]}function mn(n,t){let e=n[0],r=n[1],i=n[2],o=n[3],a=n[4],c=n[5],u=t[0],s=t[1],l=t[2],f=t[3],d=t[4],m=t[5];return Math.abs(e-u)<=h*Math.max(1,Math.abs(e),Math.abs(u))&&Math.abs(r-s)<=h*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(i-l)<=h*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(o-f)<=h*Math.max(1,Math.abs(o),Math.abs(f))&&Math.abs(a-d)<=h*Math.max(1,Math.abs(a),Math.abs(d))&&Math.abs(c-m)<=h*Math.max(1,Math.abs(c),Math.abs(m))}const _n=$,vn=ln;function gn(){let n=new d(9);return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=1,n[5]=0,n[6]=0,n[7]=0,n[8]=1,n}function Mn(n,t){return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[4],n[4]=t[5],n[5]=t[6],n[6]=t[8],n[7]=t[9],n[8]=t[10],n}function xn(n){let t=new d(9);return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t}function pn(n,t){return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n}function In(n,t,e,r,i,o,a,c,u){let s=new d(9);return s[0]=n,s[1]=t,s[2]=e,s[3]=r,s[4]=i,s[5]=o,s[6]=a,s[7]=c,s[8]=u,s}function En(n,t,e,r,i,o,a,c,u,s){return n[0]=t,n[1]=e,n[2]=r,n[3]=i,n[4]=o,n[5]=a,n[6]=c,n[7]=u,n[8]=s,n}function bn(n){return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=1,n[5]=0,n[6]=0,n[7]=0,n[8]=1,n}function Sn(n,t){if(n===t){let e=t[1],r=t[2],i=t[5];n[1]=t[3],n[2]=t[6],n[3]=e,n[5]=t[7],n[6]=r,n[7]=i}else n[0]=t[0],n[1]=t[3],n[2]=t[6],n[3]=t[1],n[4]=t[4],n[5]=t[7],n[6]=t[2],n[7]=t[5],n[8]=t[8];return n}function yn(n,t){let e=t[0],r=t[1],i=t[2],o=t[3],a=t[4],c=t[5],u=t[6],s=t[7],l=t[8],f=l*a-c*s,h=-l*o+c*u,d=s*o-a*u,m=e*f+r*h+i*d;return m?(m=1/m,n[0]=f*m,n[1]=(-l*r+i*s)*m,n[2]=(c*r-i*a)*m,n[3]=h*m,n[4]=(l*e-i*u)*m,n[5]=(-c*e+i*o)*m,n[6]=d*m,n[7]=(-s*e+r*u)*m,n[8]=(a*e-r*o)*m,n):null}function wn(n,t){let e=t[0],r=t[1],i=t[2],o=t[3],a=t[4],c=t[5],u=t[6],s=t[7],l=t[8];return n[0]=a*l-c*s,n[1]=i*s-r*l,n[2]=r*c-i*a,n[3]=c*u-o*l,n[4]=e*l-i*u,n[5]=i*o-e*c,n[6]=o*s-a*u,n[7]=r*u-e*s,n[8]=e*a-r*o,n}function Ln(n){let t=n[0],e=n[1],r=n[2],i=n[3],o=n[4],a=n[5],c=n[6],u=n[7],s=n[8];return t*(s*o-a*u)+e*(-s*i+a*c)+r*(u*i-o*c)}function Tn(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3],c=t[4],u=t[5],s=t[6],l=t[7],f=t[8],h=e[0],d=e[1],m=e[2],_=e[3],v=e[4],g=e[5],M=e[6],x=e[7],p=e[8];return n[0]=h*r+d*a+m*s,n[1]=h*i+d*c+m*l,n[2]=h*o+d*u+m*f,n[3]=_*r+v*a+g*s,n[4]=_*i+v*c+g*l,n[5]=_*o+v*u+g*f,n[6]=M*r+x*a+p*s,n[7]=M*i+x*c+p*l,n[8]=M*o+x*u+p*f,n}function Rn(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3],c=t[4],u=t[5],s=t[6],l=t[7],f=t[8],h=e[0],d=e[1];return n[0]=r,n[1]=i,n[2]=o,n[3]=a,n[4]=c,n[5]=u,n[6]=h*r+d*a+s,n[7]=h*i+d*c+l,n[8]=h*o+d*u+f,n}function Pn(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3],c=t[4],u=t[5],s=t[6],l=t[7],f=t[8],h=Math.sin(e),d=Math.cos(e);return n[0]=d*r+h*a,n[1]=d*i+h*c,n[2]=d*o+h*u,n[3]=d*a-h*r,n[4]=d*c-h*i,n[5]=d*u-h*o,n[6]=s,n[7]=l,n[8]=f,n}function Nn(n,t,e){let r=e[0],i=e[1];return n[0]=r*t[0],n[1]=r*t[1],n[2]=r*t[2],n[3]=i*t[3],n[4]=i*t[4],n[5]=i*t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n}function An(n,t){return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=1,n[5]=0,n[6]=t[0],n[7]=t[1],n[8]=1,n}function On(n,t){let e=Math.sin(t),r=Math.cos(t);return n[0]=r,n[1]=e,n[2]=0,n[3]=-e,n[4]=r,n[5]=0,n[6]=0,n[7]=0,n[8]=1,n}function zn(n,t){return n[0]=t[0],n[1]=0,n[2]=0,n[3]=0,n[4]=t[1],n[5]=0,n[6]=0,n[7]=0,n[8]=1,n}function Fn(n,t){return n[0]=t[0],n[1]=t[1],n[2]=0,n[3]=t[2],n[4]=t[3],n[5]=0,n[6]=t[4],n[7]=t[5],n[8]=1,n}function qn(n,t){let e=t[0],r=t[1],i=t[2],o=t[3],a=e+e,c=r+r,u=i+i,s=e*a,l=r*a,f=r*c,h=i*a,d=i*c,m=i*u,_=o*a,v=o*c,g=o*u;return n[0]=1-f-m,n[3]=l-g,n[6]=h+v,n[1]=l+g,n[4]=1-s-m,n[7]=d-_,n[2]=h-v,n[5]=d+_,n[8]=1-s-f,n}function Dn(n,t){let e=t[0],r=t[1],i=t[2],o=t[3],a=t[4],c=t[5],u=t[6],s=t[7],l=t[8],f=t[9],h=t[10],d=t[11],m=t[12],_=t[13],v=t[14],g=t[15],M=e*c-r*a,x=e*u-i*a,p=e*s-o*a,I=r*u-i*c,E=r*s-o*c,b=i*s-o*u,S=l*_-f*m,y=l*v-h*m,w=l*g-d*m,L=f*v-h*_,T=f*g-d*_,R=h*g-d*v,P=M*R-x*T+p*L+I*w-E*y+b*S;return P?(P=1/P,n[0]=(c*R-u*T+s*L)*P,n[1]=(u*w-a*R-s*y)*P,n[2]=(a*T-c*w+s*S)*P,n[3]=(i*T-r*R-o*L)*P,n[4]=(e*R-i*w+o*y)*P,n[5]=(r*w-e*T-o*S)*P,n[6]=(_*b-v*E+g*I)*P,n[7]=(v*p-m*b-g*x)*P,n[8]=(m*E-_*p+g*M)*P,n):null}function Cn(n,t,e){return n[0]=2/t,n[1]=0,n[2]=0,n[3]=0,n[4]=-2/e,n[5]=0,n[6]=-1,n[7]=1,n[8]=1,n}function Gn(n){return"mat3("+n[0]+", "+n[1]+", "+n[2]+", "+n[3]+", "+n[4]+", "+n[5]+", "+n[6]+", "+n[7]+", "+n[8]+")"}function Hn(n){return Math.sqrt(Math.pow(n[0],2)+Math.pow(n[1],2)+Math.pow(n[2],2)+Math.pow(n[3],2)+Math.pow(n[4],2)+Math.pow(n[5],2)+Math.pow(n[6],2)+Math.pow(n[7],2)+Math.pow(n[8],2))}function Un(n,t,e){return n[0]=t[0]+e[0],n[1]=t[1]+e[1],n[2]=t[2]+e[2],n[3]=t[3]+e[3],n[4]=t[4]+e[4],n[5]=t[5]+e[5],n[6]=t[6]+e[6],n[7]=t[7]+e[7],n[8]=t[8]+e[8],n}function Bn(n,t,e){return n[0]=t[0]-e[0],n[1]=t[1]-e[1],n[2]=t[2]-e[2],n[3]=t[3]-e[3],n[4]=t[4]-e[4],n[5]=t[5]-e[5],n[6]=t[6]-e[6],n[7]=t[7]-e[7],n[8]=t[8]-e[8],n}function Zn(n,t,e){return n[0]=t[0]*e,n[1]=t[1]*e,n[2]=t[2]*e,n[3]=t[3]*e,n[4]=t[4]*e,n[5]=t[5]*e,n[6]=t[6]*e,n[7]=t[7]*e,n[8]=t[8]*e,n}function Vn(n,t,e,r){return n[0]=t[0]+e[0]*r,n[1]=t[1]+e[1]*r,n[2]=t[2]+e[2]*r,n[3]=t[3]+e[3]*r,n[4]=t[4]+e[4]*r,n[5]=t[5]+e[5]*r,n[6]=t[6]+e[6]*r,n[7]=t[7]+e[7]*r,n[8]=t[8]+e[8]*r,n}function kn(n,t){return n[0]===t[0]&&n[1]===t[1]&&n[2]===t[2]&&n[3]===t[3]&&n[4]===t[4]&&n[5]===t[5]&&n[6]===t[6]&&n[7]===t[7]&&n[8]===t[8]}function Yn(n,t){let e=n[0],r=n[1],i=n[2],o=n[3],a=n[4],c=n[5],u=n[6],s=n[7],l=n[8],f=t[0],d=t[1],m=t[2],_=t[3],v=t[4],g=t[5],M=t[6],x=t[7],p=t[8];return Math.abs(e-f)<=h*Math.max(1,Math.abs(e),Math.abs(f))&&Math.abs(r-d)<=h*Math.max(1,Math.abs(r),Math.abs(d))&&Math.abs(i-m)<=h*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(o-_)<=h*Math.max(1,Math.abs(o),Math.abs(_))&&Math.abs(a-v)<=h*Math.max(1,Math.abs(a),Math.abs(v))&&Math.abs(c-g)<=h*Math.max(1,Math.abs(c),Math.abs(g))&&Math.abs(u-M)<=h*Math.max(1,Math.abs(u),Math.abs(M))&&Math.abs(s-x)<=h*Math.max(1,Math.abs(s),Math.abs(x))&&Math.abs(l-p)<=h*Math.max(1,Math.abs(l),Math.abs(p))}const jn=Tn,Xn=Bn;function Wn(){let n=new d(16);return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function Kn(n){let t=new d(16);return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t}function Qn(n,t){return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n}function Jn(n,t,e,r,i,o,a,c,u,s,l,f,h,m,_,v){let g=new d(16);return g[0]=n,g[1]=t,g[2]=e,g[3]=r,g[4]=i,g[5]=o,g[6]=a,g[7]=c,g[8]=u,g[9]=s,g[10]=l,g[11]=f,g[12]=h,g[13]=m,g[14]=_,g[15]=v,g}function $n(n,t,e,r,i,o,a,c,u,s,l,f,h,d,m,_,v){return n[0]=t,n[1]=e,n[2]=r,n[3]=i,n[4]=o,n[5]=a,n[6]=c,n[7]=u,n[8]=s,n[9]=l,n[10]=f,n[11]=h,n[12]=d,n[13]=m,n[14]=_,n[15]=v,n}function nt(n){return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function tt(n,t){if(n===t){let e=t[1],r=t[2],i=t[3],o=t[6],a=t[7],c=t[11];n[1]=t[4],n[2]=t[8],n[3]=t[12],n[4]=e,n[6]=t[9],n[7]=t[13],n[8]=r,n[9]=o,n[11]=t[14],n[12]=i,n[13]=a,n[14]=c}else n[0]=t[0],n[1]=t[4],n[2]=t[8],n[3]=t[12],n[4]=t[1],n[5]=t[5],n[6]=t[9],n[7]=t[13],n[8]=t[2],n[9]=t[6],n[10]=t[10],n[11]=t[14],n[12]=t[3],n[13]=t[7],n[14]=t[11],n[15]=t[15];return n}function et(n,t){let e=t[0],r=t[1],i=t[2],o=t[3],a=t[4],c=t[5],u=t[6],s=t[7],l=t[8],f=t[9],h=t[10],d=t[11],m=t[12],_=t[13],v=t[14],g=t[15],M=e*c-r*a,x=e*u-i*a,p=e*s-o*a,I=r*u-i*c,E=r*s-o*c,b=i*s-o*u,S=l*_-f*m,y=l*v-h*m,w=l*g-d*m,L=f*v-h*_,T=f*g-d*_,R=h*g-d*v,P=M*R-x*T+p*L+I*w-E*y+b*S;return P?(P=1/P,n[0]=(c*R-u*T+s*L)*P,n[1]=(i*T-r*R-o*L)*P,n[2]=(_*b-v*E+g*I)*P,n[3]=(h*E-f*b-d*I)*P,n[4]=(u*w-a*R-s*y)*P,n[5]=(e*R-i*w+o*y)*P,n[6]=(v*p-m*b-g*x)*P,n[7]=(l*b-h*p+d*x)*P,n[8]=(a*T-c*w+s*S)*P,n[9]=(r*w-e*T-o*S)*P,n[10]=(m*E-_*p+g*M)*P,n[11]=(f*p-l*E-d*M)*P,n[12]=(c*y-a*L-u*S)*P,n[13]=(e*L-r*y+i*S)*P,n[14]=(_*x-m*I-v*M)*P,n[15]=(l*I-f*x+h*M)*P,n):null}function rt(n,t){let e=t[0],r=t[1],i=t[2],o=t[3],a=t[4],c=t[5],u=t[6],s=t[7],l=t[8],f=t[9],h=t[10],d=t[11],m=t[12],_=t[13],v=t[14],g=t[15];return n[0]=c*(h*g-d*v)-f*(u*g-s*v)+_*(u*d-s*h),n[1]=-(r*(h*g-d*v)-f*(i*g-o*v)+_*(i*d-o*h)),n[2]=r*(u*g-s*v)-c*(i*g-o*v)+_*(i*s-o*u),n[3]=-(r*(u*d-s*h)-c*(i*d-o*h)+f*(i*s-o*u)),n[4]=-(a*(h*g-d*v)-l*(u*g-s*v)+m*(u*d-s*h)),n[5]=e*(h*g-d*v)-l*(i*g-o*v)+m*(i*d-o*h),n[6]=-(e*(u*g-s*v)-a*(i*g-o*v)+m*(i*s-o*u)),n[7]=e*(u*d-s*h)-a*(i*d-o*h)+l*(i*s-o*u),n[8]=a*(f*g-d*_)-l*(c*g-s*_)+m*(c*d-s*f),n[9]=-(e*(f*g-d*_)-l*(r*g-o*_)+m*(r*d-o*f)),n[10]=e*(c*g-s*_)-a*(r*g-o*_)+m*(r*s-o*c),n[11]=-(e*(c*d-s*f)-a*(r*d-o*f)+l*(r*s-o*c)),n[12]=-(a*(f*v-h*_)-l*(c*v-u*_)+m*(c*h-u*f)),n[13]=e*(f*v-h*_)-l*(r*v-i*_)+m*(r*h-i*f),n[14]=-(e*(c*v-u*_)-a*(r*v-i*_)+m*(r*u-i*c)),n[15]=e*(c*h-u*f)-a*(r*h-i*f)+l*(r*u-i*c),n}function it(n){let t=n[0],e=n[1],r=n[2],i=n[3],o=n[4],a=n[5],c=n[6],u=n[7],s=n[8],l=n[9],f=n[10],h=n[11],d=n[12],m=n[13],_=n[14],v=n[15];return(t*a-e*o)*(f*v-h*_)-(t*c-r*o)*(l*v-h*m)+(t*u-i*o)*(l*_-f*m)+(e*c-r*a)*(s*v-h*d)-(e*u-i*a)*(s*_-f*d)+(r*u-i*c)*(s*m-l*d)}function ot(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3],c=t[4],u=t[5],s=t[6],l=t[7],f=t[8],h=t[9],d=t[10],m=t[11],_=t[12],v=t[13],g=t[14],M=t[15],x=e[0],p=e[1],I=e[2],E=e[3];return n[0]=x*r+p*c+I*f+E*_,n[1]=x*i+p*u+I*h+E*v,n[2]=x*o+p*s+I*d+E*g,n[3]=x*a+p*l+I*m+E*M,x=e[4],p=e[5],I=e[6],E=e[7],n[4]=x*r+p*c+I*f+E*_,n[5]=x*i+p*u+I*h+E*v,n[6]=x*o+p*s+I*d+E*g,n[7]=x*a+p*l+I*m+E*M,x=e[8],p=e[9],I=e[10],E=e[11],n[8]=x*r+p*c+I*f+E*_,n[9]=x*i+p*u+I*h+E*v,n[10]=x*o+p*s+I*d+E*g,n[11]=x*a+p*l+I*m+E*M,x=e[12],p=e[13],I=e[14],E=e[15],n[12]=x*r+p*c+I*f+E*_,n[13]=x*i+p*u+I*h+E*v,n[14]=x*o+p*s+I*d+E*g,n[15]=x*a+p*l+I*m+E*M,n}function at(n,t,e){let r,i,o,a,c,u,s,l,f,h,d,m,_=e[0],v=e[1],g=e[2];return t===n?(n[12]=t[0]*_+t[4]*v+t[8]*g+t[12],n[13]=t[1]*_+t[5]*v+t[9]*g+t[13],n[14]=t[2]*_+t[6]*v+t[10]*g+t[14],n[15]=t[3]*_+t[7]*v+t[11]*g+t[15]):(r=t[0],i=t[1],o=t[2],a=t[3],c=t[4],u=t[5],s=t[6],l=t[7],f=t[8],h=t[9],d=t[10],m=t[11],n[0]=r,n[1]=i,n[2]=o,n[3]=a,n[4]=c,n[5]=u,n[6]=s,n[7]=l,n[8]=f,n[9]=h,n[10]=d,n[11]=m,n[12]=r*_+c*v+f*g+t[12],n[13]=i*_+u*v+h*g+t[13],n[14]=o*_+s*v+d*g+t[14],n[15]=a*_+l*v+m*g+t[15]),n}function ct(n,t,e){let r=e[0],i=e[1],o=e[2];return n[0]=t[0]*r,n[1]=t[1]*r,n[2]=t[2]*r,n[3]=t[3]*r,n[4]=t[4]*i,n[5]=t[5]*i,n[6]=t[6]*i,n[7]=t[7]*i,n[8]=t[8]*o,n[9]=t[9]*o,n[10]=t[10]*o,n[11]=t[11]*o,n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n}function ut(n,t,e,r){let i,o,a,c,u,s,l,f,d,m,_,v,g,M,x,p,I,E,b,S,y,w,L,T,R=r[0],P=r[1],N=r[2],A=Math.sqrt(R*R+P*P+N*N);return Math.abs(A)<h?null:(R*=A=1/A,P*=A,N*=A,i=Math.sin(e),a=1-(o=Math.cos(e)),c=t[0],u=t[1],s=t[2],l=t[3],f=t[4],d=t[5],m=t[6],_=t[7],v=t[8],g=t[9],M=t[10],x=t[11],p=R*R*a+o,I=P*R*a+N*i,E=N*R*a-P*i,b=R*P*a-N*i,S=P*P*a+o,y=N*P*a+R*i,w=R*N*a+P*i,L=P*N*a-R*i,T=N*N*a+o,n[0]=c*p+f*I+v*E,n[1]=u*p+d*I+g*E,n[2]=s*p+m*I+M*E,n[3]=l*p+_*I+x*E,n[4]=c*b+f*S+v*y,n[5]=u*b+d*S+g*y,n[6]=s*b+m*S+M*y,n[7]=l*b+_*S+x*y,n[8]=c*w+f*L+v*T,n[9]=u*w+d*L+g*T,n[10]=s*w+m*L+M*T,n[11]=l*w+_*L+x*T,t!==n&&(n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n)}function st(n,t,e){let r=Math.sin(e),i=Math.cos(e),o=t[4],a=t[5],c=t[6],u=t[7],s=t[8],l=t[9],f=t[10],h=t[11];return t!==n&&(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n[4]=o*i+s*r,n[5]=a*i+l*r,n[6]=c*i+f*r,n[7]=u*i+h*r,n[8]=s*i-o*r,n[9]=l*i-a*r,n[10]=f*i-c*r,n[11]=h*i-u*r,n}function lt(n,t,e){let r=Math.sin(e),i=Math.cos(e),o=t[0],a=t[1],c=t[2],u=t[3],s=t[8],l=t[9],f=t[10],h=t[11];return t!==n&&(n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n[0]=o*i-s*r,n[1]=a*i-l*r,n[2]=c*i-f*r,n[3]=u*i-h*r,n[8]=o*r+s*i,n[9]=a*r+l*i,n[10]=c*r+f*i,n[11]=u*r+h*i,n}function ft(n,t,e){let r=Math.sin(e),i=Math.cos(e),o=t[0],a=t[1],c=t[2],u=t[3],s=t[4],l=t[5],f=t[6],h=t[7];return t!==n&&(n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n[0]=o*i+s*r,n[1]=a*i+l*r,n[2]=c*i+f*r,n[3]=u*i+h*r,n[4]=s*i-o*r,n[5]=l*i-a*r,n[6]=f*i-c*r,n[7]=h*i-u*r,n}function ht(n,t){return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=t[0],n[13]=t[1],n[14]=t[2],n[15]=1,n}function dt(n,t){return n[0]=t[0],n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=t[1],n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=t[2],n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function mt(n,t,e){let r,i,o,a=e[0],c=e[1],u=e[2],s=Math.sqrt(a*a+c*c+u*u);return Math.abs(s)<h?null:(a*=s=1/s,c*=s,u*=s,r=Math.sin(t),o=1-(i=Math.cos(t)),n[0]=a*a*o+i,n[1]=c*a*o+u*r,n[2]=u*a*o-c*r,n[3]=0,n[4]=a*c*o-u*r,n[5]=c*c*o+i,n[6]=u*c*o+a*r,n[7]=0,n[8]=a*u*o+c*r,n[9]=c*u*o-a*r,n[10]=u*u*o+i,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n)}function _t(n,t){let e=Math.sin(t),r=Math.cos(t);return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=r,n[6]=e,n[7]=0,n[8]=0,n[9]=-e,n[10]=r,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function vt(n,t){let e=Math.sin(t),r=Math.cos(t);return n[0]=r,n[1]=0,n[2]=-e,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=e,n[9]=0,n[10]=r,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function gt(n,t){let e=Math.sin(t),r=Math.cos(t);return n[0]=r,n[1]=e,n[2]=0,n[3]=0,n[4]=-e,n[5]=r,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function Mt(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3],c=r+r,u=i+i,s=o+o,l=r*c,f=r*u,h=r*s,d=i*u,m=i*s,_=o*s,v=a*c,g=a*u,M=a*s;return n[0]=1-(d+_),n[1]=f+M,n[2]=h-g,n[3]=0,n[4]=f-M,n[5]=1-(l+_),n[6]=m+v,n[7]=0,n[8]=h+g,n[9]=m-v,n[10]=1-(l+d),n[11]=0,n[12]=e[0],n[13]=e[1],n[14]=e[2],n[15]=1,n}function xt(n,t){return n[0]=t[12],n[1]=t[13],n[2]=t[14],n}function pt(n,t){let e=t[0],r=t[1],i=t[2],o=t[4],a=t[5],c=t[6],u=t[8],s=t[9],l=t[10];return n[0]=Math.sqrt(e*e+r*r+i*i),n[1]=Math.sqrt(o*o+a*a+c*c),n[2]=Math.sqrt(u*u+s*s+l*l),n}function It(n,t){let e=t[0]+t[5]+t[10],r=0;return e>0?(r=2*Math.sqrt(e+1),n[3]=.25*r,n[0]=(t[6]-t[9])/r,n[1]=(t[8]-t[2])/r,n[2]=(t[1]-t[4])/r):t[0]>t[5]&&t[0]>t[10]?(r=2*Math.sqrt(1+t[0]-t[5]-t[10]),n[3]=(t[6]-t[9])/r,n[0]=.25*r,n[1]=(t[1]+t[4])/r,n[2]=(t[8]+t[2])/r):t[5]>t[10]?(r=2*Math.sqrt(1+t[5]-t[0]-t[10]),n[3]=(t[8]-t[2])/r,n[0]=(t[1]+t[4])/r,n[1]=.25*r,n[2]=(t[6]+t[9])/r):(r=2*Math.sqrt(1+t[10]-t[0]-t[5]),n[3]=(t[1]-t[4])/r,n[0]=(t[8]+t[2])/r,n[1]=(t[6]+t[9])/r,n[2]=.25*r),n}function Et(n,t,e,r){let i=t[0],o=t[1],a=t[2],c=t[3],u=i+i,s=o+o,l=a+a,f=i*u,h=i*s,d=i*l,m=o*s,_=o*l,v=a*l,g=c*u,M=c*s,x=c*l,p=r[0],I=r[1],E=r[2];return n[0]=(1-(m+v))*p,n[1]=(h+x)*p,n[2]=(d-M)*p,n[3]=0,n[4]=(h-x)*I,n[5]=(1-(f+v))*I,n[6]=(_+g)*I,n[7]=0,n[8]=(d+M)*E,n[9]=(_-g)*E,n[10]=(1-(f+m))*E,n[11]=0,n[12]=e[0],n[13]=e[1],n[14]=e[2],n[15]=1,n}function bt(n,t,e,r,i){let o=t[0],a=t[1],c=t[2],u=t[3],s=o+o,l=a+a,f=c+c,h=o*s,d=o*l,m=o*f,_=a*l,v=a*f,g=c*f,M=u*s,x=u*l,p=u*f,I=r[0],E=r[1],b=r[2],S=i[0],y=i[1],w=i[2],L=(1-(_+g))*I,T=(d+p)*I,R=(m-x)*I,P=(d-p)*E,N=(1-(h+g))*E,A=(v+M)*E,O=(m+x)*b,z=(v-M)*b,F=(1-(h+_))*b;return n[0]=L,n[1]=T,n[2]=R,n[3]=0,n[4]=P,n[5]=N,n[6]=A,n[7]=0,n[8]=O,n[9]=z,n[10]=F,n[11]=0,n[12]=e[0]+S-(L*S+P*y+O*w),n[13]=e[1]+y-(T*S+N*y+z*w),n[14]=e[2]+w-(R*S+A*y+F*w),n[15]=1,n}function St(n,t){let e=t[0],r=t[1],i=t[2],o=t[3],a=e+e,c=r+r,u=i+i,s=e*a,l=r*a,f=r*c,h=i*a,d=i*c,m=i*u,_=o*a,v=o*c,g=o*u;return n[0]=1-f-m,n[1]=l+g,n[2]=h-v,n[3]=0,n[4]=l-g,n[5]=1-s-m,n[6]=d+_,n[7]=0,n[8]=h+v,n[9]=d-_,n[10]=1-s-f,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function yt(n,t,e,r,i,o,a){let c=1/(e-t),u=1/(i-r),s=1/(o-a);return n[0]=2*o*c,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=2*o*u,n[6]=0,n[7]=0,n[8]=(e+t)*c,n[9]=(i+r)*u,n[10]=(a+o)*s,n[11]=-1,n[12]=0,n[13]=0,n[14]=a*o*2*s,n[15]=0,n}function wt(n,t,e,r,i){let o=1/Math.tan(t/2),a=1/(r-i);return n[0]=o/e,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=o,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=(i+r)*a,n[11]=-1,n[12]=0,n[13]=0,n[14]=2*i*r*a,n[15]=0,n}function Lt(n,t,e,r){let i=Math.tan(t.upDegrees*Math.PI/180),o=Math.tan(t.downDegrees*Math.PI/180),a=Math.tan(t.leftDegrees*Math.PI/180),c=Math.tan(t.rightDegrees*Math.PI/180),u=2/(a+c),s=2/(i+o);return n[0]=u,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=s,n[6]=0,n[7]=0,n[8]=-(a-c)*u*.5,n[9]=(i-o)*s*.5,n[10]=r/(e-r),n[11]=-1,n[12]=0,n[13]=0,n[14]=r*e/(e-r),n[15]=0,n}function Tt(n,t,e,r,i,o,a){let c=1/(t-e),u=1/(r-i),s=1/(o-a);return n[0]=-2*c,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=-2*u,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=2*s,n[11]=0,n[12]=(t+e)*c,n[13]=(i+r)*u,n[14]=(a+o)*s,n[15]=1,n}function Rt(n,t,e,r){let i,o,a,c,u,s,l,f,d,m,_=t[0],v=t[1],g=t[2],M=r[0],x=r[1],p=r[2],I=e[0],E=e[1],b=e[2];return Math.abs(_-I)<h&&Math.abs(v-E)<h&&Math.abs(g-b)<h?nt(n):(l=_-I,f=v-E,d=g-b,i=x*(d*=m=1/Math.sqrt(l*l+f*f+d*d))-p*(f*=m),o=p*(l*=m)-M*d,a=M*f-x*l,(m=Math.sqrt(i*i+o*o+a*a))?(i*=m=1/m,o*=m,a*=m):(i=0,o=0,a=0),c=f*a-d*o,u=d*i-l*a,s=l*o-f*i,(m=Math.sqrt(c*c+u*u+s*s))?(c*=m=1/m,u*=m,s*=m):(c=0,u=0,s=0),n[0]=i,n[1]=c,n[2]=l,n[3]=0,n[4]=o,n[5]=u,n[6]=f,n[7]=0,n[8]=a,n[9]=s,n[10]=d,n[11]=0,n[12]=-(i*_+o*v+a*g),n[13]=-(c*_+u*v+s*g),n[14]=-(l*_+f*v+d*g),n[15]=1,n)}function Pt(n,t,e,r){let i=t[0],o=t[1],a=t[2],c=r[0],u=r[1],s=r[2],l=i-e[0],f=o-e[1],h=a-e[2],d=l*l+f*f+h*h;d>0&&(l*=d=1/Math.sqrt(d),f*=d,h*=d);let m=u*h-s*f,_=s*l-c*h,v=c*f-u*l;return(d=m*m+_*_+v*v)>0&&(m*=d=1/Math.sqrt(d),_*=d,v*=d),n[0]=m,n[1]=_,n[2]=v,n[3]=0,n[4]=f*v-h*_,n[5]=h*m-l*v,n[6]=l*_-f*m,n[7]=0,n[8]=l,n[9]=f,n[10]=h,n[11]=0,n[12]=i,n[13]=o,n[14]=a,n[15]=1,n}function Nt(n){return"mat4("+n[0]+", "+n[1]+", "+n[2]+", "+n[3]+", "+n[4]+", "+n[5]+", "+n[6]+", "+n[7]+", "+n[8]+", "+n[9]+", "+n[10]+", "+n[11]+", "+n[12]+", "+n[13]+", "+n[14]+", "+n[15]+")"}function At(n){return Math.sqrt(Math.pow(n[0],2)+Math.pow(n[1],2)+Math.pow(n[2],2)+Math.pow(n[3],2)+Math.pow(n[4],2)+Math.pow(n[5],2)+Math.pow(n[6],2)+Math.pow(n[7],2)+Math.pow(n[8],2)+Math.pow(n[9],2)+Math.pow(n[10],2)+Math.pow(n[11],2)+Math.pow(n[12],2)+Math.pow(n[13],2)+Math.pow(n[14],2)+Math.pow(n[15],2))}function Ot(n,t,e){return n[0]=t[0]+e[0],n[1]=t[1]+e[1],n[2]=t[2]+e[2],n[3]=t[3]+e[3],n[4]=t[4]+e[4],n[5]=t[5]+e[5],n[6]=t[6]+e[6],n[7]=t[7]+e[7],n[8]=t[8]+e[8],n[9]=t[9]+e[9],n[10]=t[10]+e[10],n[11]=t[11]+e[11],n[12]=t[12]+e[12],n[13]=t[13]+e[13],n[14]=t[14]+e[14],n[15]=t[15]+e[15],n}function zt(n,t,e){return n[0]=t[0]-e[0],n[1]=t[1]-e[1],n[2]=t[2]-e[2],n[3]=t[3]-e[3],n[4]=t[4]-e[4],n[5]=t[5]-e[5],n[6]=t[6]-e[6],n[7]=t[7]-e[7],n[8]=t[8]-e[8],n[9]=t[9]-e[9],n[10]=t[10]-e[10],n[11]=t[11]-e[11],n[12]=t[12]-e[12],n[13]=t[13]-e[13],n[14]=t[14]-e[14],n[15]=t[15]-e[15],n}function Ft(n,t,e){return n[0]=t[0]*e,n[1]=t[1]*e,n[2]=t[2]*e,n[3]=t[3]*e,n[4]=t[4]*e,n[5]=t[5]*e,n[6]=t[6]*e,n[7]=t[7]*e,n[8]=t[8]*e,n[9]=t[9]*e,n[10]=t[10]*e,n[11]=t[11]*e,n[12]=t[12]*e,n[13]=t[13]*e,n[14]=t[14]*e,n[15]=t[15]*e,n}function qt(n,t,e,r){return n[0]=t[0]+e[0]*r,n[1]=t[1]+e[1]*r,n[2]=t[2]+e[2]*r,n[3]=t[3]+e[3]*r,n[4]=t[4]+e[4]*r,n[5]=t[5]+e[5]*r,n[6]=t[6]+e[6]*r,n[7]=t[7]+e[7]*r,n[8]=t[8]+e[8]*r,n[9]=t[9]+e[9]*r,n[10]=t[10]+e[10]*r,n[11]=t[11]+e[11]*r,n[12]=t[12]+e[12]*r,n[13]=t[13]+e[13]*r,n[14]=t[14]+e[14]*r,n[15]=t[15]+e[15]*r,n}function Dt(n,t){return n[0]===t[0]&&n[1]===t[1]&&n[2]===t[2]&&n[3]===t[3]&&n[4]===t[4]&&n[5]===t[5]&&n[6]===t[6]&&n[7]===t[7]&&n[8]===t[8]&&n[9]===t[9]&&n[10]===t[10]&&n[11]===t[11]&&n[12]===t[12]&&n[13]===t[13]&&n[14]===t[14]&&n[15]===t[15]}function Ct(n,t){let e=n[0],r=n[1],i=n[2],o=n[3],a=n[4],c=n[5],u=n[6],s=n[7],l=n[8],f=n[9],d=n[10],m=n[11],_=n[12],v=n[13],g=n[14],M=n[15],x=t[0],p=t[1],I=t[2],E=t[3],b=t[4],S=t[5],y=t[6],w=t[7],L=t[8],T=t[9],R=t[10],P=t[11],N=t[12],A=t[13],O=t[14],z=t[15];return Math.abs(e-x)<=h*Math.max(1,Math.abs(e),Math.abs(x))&&Math.abs(r-p)<=h*Math.max(1,Math.abs(r),Math.abs(p))&&Math.abs(i-I)<=h*Math.max(1,Math.abs(i),Math.abs(I))&&Math.abs(o-E)<=h*Math.max(1,Math.abs(o),Math.abs(E))&&Math.abs(a-b)<=h*Math.max(1,Math.abs(a),Math.abs(b))&&Math.abs(c-S)<=h*Math.max(1,Math.abs(c),Math.abs(S))&&Math.abs(u-y)<=h*Math.max(1,Math.abs(u),Math.abs(y))&&Math.abs(s-w)<=h*Math.max(1,Math.abs(s),Math.abs(w))&&Math.abs(l-L)<=h*Math.max(1,Math.abs(l),Math.abs(L))&&Math.abs(f-T)<=h*Math.max(1,Math.abs(f),Math.abs(T))&&Math.abs(d-R)<=h*Math.max(1,Math.abs(d),Math.abs(R))&&Math.abs(m-P)<=h*Math.max(1,Math.abs(m),Math.abs(P))&&Math.abs(_-N)<=h*Math.max(1,Math.abs(_),Math.abs(N))&&Math.abs(v-A)<=h*Math.max(1,Math.abs(v),Math.abs(A))&&Math.abs(g-O)<=h*Math.max(1,Math.abs(g),Math.abs(O))&&Math.abs(M-z)<=h*Math.max(1,Math.abs(M),Math.abs(z))}const Gt=ot,Ht=zt;function Ut(){let n=new d(3);return n[0]=0,n[1]=0,n[2]=0,n}function Bt(n){var t=new d(3);return t[0]=n[0],t[1]=n[1],t[2]=n[2],t}function Zt(n){let t=n[0],e=n[1],r=n[2];return Math.sqrt(t*t+e*e+r*r)}function Vt(n,t,e){let r=new d(3);return r[0]=n,r[1]=t,r[2]=e,r}function kt(n,t){return n[0]=t[0],n[1]=t[1],n[2]=t[2],n}function Yt(n,t,e,r){return n[0]=t,n[1]=e,n[2]=r,n}function jt(n,t,e){return n[0]=t[0]+e[0],n[1]=t[1]+e[1],n[2]=t[2]+e[2],n}function Xt(n,t,e){return n[0]=t[0]-e[0],n[1]=t[1]-e[1],n[2]=t[2]-e[2],n}function Wt(n,t,e){return n[0]=t[0]*e[0],n[1]=t[1]*e[1],n[2]=t[2]*e[2],n}function Kt(n,t,e){return n[0]=t[0]/e[0],n[1]=t[1]/e[1],n[2]=t[2]/e[2],n}function Qt(n,t){return n[0]=Math.ceil(t[0]),n[1]=Math.ceil(t[1]),n[2]=Math.ceil(t[2]),n}function Jt(n,t){return n[0]=Math.floor(t[0]),n[1]=Math.floor(t[1]),n[2]=Math.floor(t[2]),n}function $t(n,t,e){return n[0]=Math.min(t[0],e[0]),n[1]=Math.min(t[1],e[1]),n[2]=Math.min(t[2],e[2]),n}function ne(n,t,e){return n[0]=Math.max(t[0],e[0]),n[1]=Math.max(t[1],e[1]),n[2]=Math.max(t[2],e[2]),n}function te(n,t){return n[0]=Math.round(t[0]),n[1]=Math.round(t[1]),n[2]=Math.round(t[2]),n}function ee(n,t,e){return n[0]=t[0]*e,n[1]=t[1]*e,n[2]=t[2]*e,n}function re(n,t,e,r){return n[0]=t[0]+e[0]*r,n[1]=t[1]+e[1]*r,n[2]=t[2]+e[2]*r,n}function ie(n,t){let e=t[0]-n[0],r=t[1]-n[1],i=t[2]-n[2];return Math.sqrt(e*e+r*r+i*i)}function oe(n,t){let e=t[0]-n[0],r=t[1]-n[1],i=t[2]-n[2];return e*e+r*r+i*i}function ae(n){let t=n[0],e=n[1],r=n[2];return t*t+e*e+r*r}function ce(n,t){return n[0]=-t[0],n[1]=-t[1],n[2]=-t[2],n}function ue(n,t){return n[0]=1/t[0],n[1]=1/t[1],n[2]=1/t[2],n}function se(n,t){let e=t[0],r=t[1],i=t[2],o=e*e+r*r+i*i;return o>0&&(o=1/Math.sqrt(o),n[0]=t[0]*o,n[1]=t[1]*o,n[2]=t[2]*o),n}function le(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function fe(n,t,e){let r=t[0],i=t[1],o=t[2],a=e[0],c=e[1],u=e[2];return n[0]=i*u-o*c,n[1]=o*a-r*u,n[2]=r*c-i*a,n}function he(n,t,e,r){let i=t[0],o=t[1],a=t[2];return n[0]=i+r*(e[0]-i),n[1]=o+r*(e[1]-o),n[2]=a+r*(e[2]-a),n}function de(n,t,e,r,i,o){let a=o*o,c=a*(2*o-3)+1,u=a*(o-2)+o,s=a*(o-1),l=a*(3-2*o);return n[0]=t[0]*c+e[0]*u+r[0]*s+i[0]*l,n[1]=t[1]*c+e[1]*u+r[1]*s+i[1]*l,n[2]=t[2]*c+e[2]*u+r[2]*s+i[2]*l,n}function me(n,t,e,r,i,o){let a=1-o,c=a*a,u=o*o,s=c*a,l=3*o*c,f=3*u*a,h=u*o;return n[0]=t[0]*s+e[0]*l+r[0]*f+i[0]*h,n[1]=t[1]*s+e[1]*l+r[1]*f+i[1]*h,n[2]=t[2]*s+e[2]*l+r[2]*f+i[2]*h,n}function _e(n,t){t=t||1;let e=2*m()*Math.PI,r=2*m()-1,i=Math.sqrt(1-r*r)*t;return n[0]=Math.cos(e)*i,n[1]=Math.sin(e)*i,n[2]=r*t,n}function ve(n,t,e){let r=t[0],i=t[1],o=t[2],a=e[3]*r+e[7]*i+e[11]*o+e[15];return a=a||1,n[0]=(e[0]*r+e[4]*i+e[8]*o+e[12])/a,n[1]=(e[1]*r+e[5]*i+e[9]*o+e[13])/a,n[2]=(e[2]*r+e[6]*i+e[10]*o+e[14])/a,n}function ge(n,t,e){let r=t[0],i=t[1],o=t[2];return n[0]=r*e[0]+i*e[3]+o*e[6],n[1]=r*e[1]+i*e[4]+o*e[7],n[2]=r*e[2]+i*e[5]+o*e[8],n}function Me(n,t,e){let r=t[0],i=t[1],o=t[2],a=e[0],c=e[1],u=e[2],s=e[3],l=s*r+c*o-u*i,f=s*i+u*r-a*o,h=s*o+a*i-c*r,d=-a*r-c*i-u*o;return n[0]=l*s+d*-a+f*-u-h*-c,n[1]=f*s+d*-c+h*-a-l*-u,n[2]=h*s+d*-u+l*-c-f*-a,n}function xe(n,t,e,r){let i=[],o=[];return i[0]=t[0]-e[0],i[1]=t[1]-e[1],i[2]=t[2]-e[2],o[0]=i[0],o[1]=i[1]*Math.cos(r)-i[2]*Math.sin(r),o[2]=i[1]*Math.sin(r)+i[2]*Math.cos(r),n[0]=o[0]+e[0],n[1]=o[1]+e[1],n[2]=o[2]+e[2],n}function pe(n,t,e,r){let i=[],o=[];return i[0]=t[0]-e[0],i[1]=t[1]-e[1],i[2]=t[2]-e[2],o[0]=i[2]*Math.sin(r)+i[0]*Math.cos(r),o[1]=i[1],o[2]=i[2]*Math.cos(r)-i[0]*Math.sin(r),n[0]=o[0]+e[0],n[1]=o[1]+e[1],n[2]=o[2]+e[2],n}function Ie(n,t,e,r){let i=[],o=[];return i[0]=t[0]-e[0],i[1]=t[1]-e[1],i[2]=t[2]-e[2],o[0]=i[0]*Math.cos(r)-i[1]*Math.sin(r),o[1]=i[0]*Math.sin(r)+i[1]*Math.cos(r),o[2]=i[2],n[0]=o[0]+e[0],n[1]=o[1]+e[1],n[2]=o[2]+e[2],n}function Ee(n,t){let e=Vt(n[0],n[1],n[2]),r=Vt(t[0],t[1],t[2]);se(e,e),se(r,r);let i=le(e,r);return i>1?0:i<-1?Math.PI:Math.acos(i)}function be(n){return"vec3("+n[0]+", "+n[1]+", "+n[2]+")"}function Se(n,t){return n[0]===t[0]&&n[1]===t[1]&&n[2]===t[2]}function ye(n,t){let e=n[0],r=n[1],i=n[2],o=t[0],a=t[1],c=t[2];return Math.abs(e-o)<=h*Math.max(1,Math.abs(e),Math.abs(o))&&Math.abs(r-a)<=h*Math.max(1,Math.abs(r),Math.abs(a))&&Math.abs(i-c)<=h*Math.max(1,Math.abs(i),Math.abs(c))}const we=Xt,Le=Wt,Te=Kt,Re=ie,Pe=oe,Ne=Zt,Ae=ae,Oe=function(){let n=Ut();return function(t,e,r,i,o,a){let c,u;for(e||(e=3),r||(r=0),u=i?Math.min(i*e+r,t.length):t.length,c=r;c<u;c+=e)n[0]=t[c],n[1]=t[c+1],n[2]=t[c+2],o(n,n,a),t[c]=n[0],t[c+1]=n[1],t[c+2]=n[2];return t}}();function ze(){let n=new d(4);return n[0]=0,n[1]=0,n[2]=0,n[3]=0,n}function Fe(n){let t=new d(4);return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t}function qe(n,t,e,r){let i=new d(4);return i[0]=n,i[1]=t,i[2]=e,i[3]=r,i}function De(n,t){return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n}function Ce(n,t,e,r,i){return n[0]=t,n[1]=e,n[2]=r,n[3]=i,n}function Ge(n,t,e){return n[0]=t[0]+e[0],n[1]=t[1]+e[1],n[2]=t[2]+e[2],n[3]=t[3]+e[3],n}function He(n,t,e){return n[0]=t[0]-e[0],n[1]=t[1]-e[1],n[2]=t[2]-e[2],n[3]=t[3]-e[3],n}function Ue(n,t,e){return n[0]=t[0]*e[0],n[1]=t[1]*e[1],n[2]=t[2]*e[2],n[3]=t[3]*e[3],n}function Be(n,t,e){return n[0]=t[0]/e[0],n[1]=t[1]/e[1],n[2]=t[2]/e[2],n[3]=t[3]/e[3],n}function Ze(n,t){return n[0]=Math.ceil(t[0]),n[1]=Math.ceil(t[1]),n[2]=Math.ceil(t[2]),n[3]=Math.ceil(t[3]),n}function Ve(n,t){return n[0]=Math.floor(t[0]),n[1]=Math.floor(t[1]),n[2]=Math.floor(t[2]),n[3]=Math.floor(t[3]),n}function ke(n,t,e){return n[0]=Math.min(t[0],e[0]),n[1]=Math.min(t[1],e[1]),n[2]=Math.min(t[2],e[2]),n[3]=Math.min(t[3],e[3]),n}function Ye(n,t,e){return n[0]=Math.max(t[0],e[0]),n[1]=Math.max(t[1],e[1]),n[2]=Math.max(t[2],e[2]),n[3]=Math.max(t[3],e[3]),n}function je(n,t){return n[0]=Math.round(t[0]),n[1]=Math.round(t[1]),n[2]=Math.round(t[2]),n[3]=Math.round(t[3]),n}function Xe(n,t,e){return n[0]=t[0]*e,n[1]=t[1]*e,n[2]=t[2]*e,n[3]=t[3]*e,n}function We(n,t,e,r){return n[0]=t[0]+e[0]*r,n[1]=t[1]+e[1]*r,n[2]=t[2]+e[2]*r,n[3]=t[3]+e[3]*r,n}function Ke(n,t){let e=t[0]-n[0],r=t[1]-n[1],i=t[2]-n[2],o=t[3]-n[3];return Math.sqrt(e*e+r*r+i*i+o*o)}function Qe(n,t){let e=t[0]-n[0],r=t[1]-n[1],i=t[2]-n[2],o=t[3]-n[3];return e*e+r*r+i*i+o*o}function Je(n){let t=n[0],e=n[1],r=n[2],i=n[3];return Math.sqrt(t*t+e*e+r*r+i*i)}function $e(n){let t=n[0],e=n[1],r=n[2],i=n[3];return t*t+e*e+r*r+i*i}function nr(n,t){return n[0]=-t[0],n[1]=-t[1],n[2]=-t[2],n[3]=-t[3],n}function tr(n,t){return n[0]=1/t[0],n[1]=1/t[1],n[2]=1/t[2],n[3]=1/t[3],n}function er(n,t){let e=t[0],r=t[1],i=t[2],o=t[3],a=e*e+r*r+i*i+o*o;return a>0&&(a=1/Math.sqrt(a),n[0]=e*a,n[1]=r*a,n[2]=i*a,n[3]=o*a),n}function rr(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function ir(n,t,e,r){let i=t[0],o=t[1],a=t[2],c=t[3];return n[0]=i+r*(e[0]-i),n[1]=o+r*(e[1]-o),n[2]=a+r*(e[2]-a),n[3]=c+r*(e[3]-c),n}function or(n,t){return t=t||1,n[0]=m(),n[1]=m(),n[2]=m(),n[3]=m(),er(n,n),Xe(n,n,t),n}function ar(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3];return n[0]=e[0]*r+e[4]*i+e[8]*o+e[12]*a,n[1]=e[1]*r+e[5]*i+e[9]*o+e[13]*a,n[2]=e[2]*r+e[6]*i+e[10]*o+e[14]*a,n[3]=e[3]*r+e[7]*i+e[11]*o+e[15]*a,n}function cr(n,t,e){let r=t[0],i=t[1],o=t[2],a=e[0],c=e[1],u=e[2],s=e[3],l=s*r+c*o-u*i,f=s*i+u*r-a*o,h=s*o+a*i-c*r,d=-a*r-c*i-u*o;return n[0]=l*s+d*-a+f*-u-h*-c,n[1]=f*s+d*-c+h*-a-l*-u,n[2]=h*s+d*-u+l*-c-f*-a,n[3]=t[3],n}function ur(n){return"vec4("+n[0]+", "+n[1]+", "+n[2]+", "+n[3]+")"}function sr(n,t){return n[0]===t[0]&&n[1]===t[1]&&n[2]===t[2]&&n[3]===t[3]}function lr(n,t){let e=n[0],r=n[1],i=n[2],o=n[3],a=t[0],c=t[1],u=t[2],s=t[3];return Math.abs(e-a)<=h*Math.max(1,Math.abs(e),Math.abs(a))&&Math.abs(r-c)<=h*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(i-u)<=h*Math.max(1,Math.abs(i),Math.abs(u))&&Math.abs(o-s)<=h*Math.max(1,Math.abs(o),Math.abs(s))}const fr=He,hr=Ue,dr=Be,mr=Ke,_r=Qe,vr=Je,gr=$e,Mr=function(){let n=ze();return function(t,e,r,i,o,a){let c,u;for(e||(e=4),r||(r=0),u=i?Math.min(i*e+r,t.length):t.length,c=r;c<u;c+=e)n[0]=t[c],n[1]=t[c+1],n[2]=t[c+2],n[3]=t[c+3],o(n,n,a),t[c]=n[0],t[c+1]=n[1],t[c+2]=n[2],t[c+3]=n[3];return t}}();function xr(){let n=new d(4);return n[0]=0,n[1]=0,n[2]=0,n[3]=1,n}function pr(n){return n[0]=0,n[1]=0,n[2]=0,n[3]=1,n}function Ir(n,t,e){e*=.5;let r=Math.sin(e);return n[0]=r*t[0],n[1]=r*t[1],n[2]=r*t[2],n[3]=Math.cos(e),n}function Er(n,t){let e=2*Math.acos(t[3]),r=Math.sin(e/2);return 0!=r?(n[0]=t[0]/r,n[1]=t[1]/r,n[2]=t[2]/r):(n[0]=1,n[1]=0,n[2]=0),e}function br(n,t,e){let r=t[0],i=t[1],o=t[2],a=t[3],c=e[0],u=e[1],s=e[2],l=e[3];return n[0]=r*l+a*c+i*s-o*u,n[1]=i*l+a*u+o*c-r*s,n[2]=o*l+a*s+r*u-i*c,n[3]=a*l-r*c-i*u-o*s,n}function Sr(n,t,e){e*=.5;let r=t[0],i=t[1],o=t[2],a=t[3],c=Math.sin(e),u=Math.cos(e);return n[0]=r*u+a*c,n[1]=i*u+o*c,n[2]=o*u-i*c,n[3]=a*u-r*c,n}function yr(n,t,e){e*=.5;let r=t[0],i=t[1],o=t[2],a=t[3],c=Math.sin(e),u=Math.cos(e);return n[0]=r*u-o*c,n[1]=i*u+a*c,n[2]=o*u+r*c,n[3]=a*u-i*c,n}function wr(n,t,e){e*=.5;let r=t[0],i=t[1],o=t[2],a=t[3],c=Math.sin(e),u=Math.cos(e);return n[0]=r*u+i*c,n[1]=i*u-r*c,n[2]=o*u+a*c,n[3]=a*u-o*c,n}function Lr(n,t){let e=t[0],r=t[1],i=t[2];return n[0]=e,n[1]=r,n[2]=i,n[3]=Math.sqrt(Math.abs(1-e*e-r*r-i*i)),n}function Tr(n,t,e,r){let i,o,a,c,u,s=t[0],l=t[1],f=t[2],h=t[3],d=e[0],m=e[1],_=e[2],v=e[3];return(o=s*d+l*m+f*_+h*v)<0&&(o=-o,d=-d,m=-m,_=-_,v=-v),1-o>1e-6?(i=Math.acos(o),a=Math.sin(i),c=Math.sin((1-r)*i)/a,u=Math.sin(r*i)/a):(c=1-r,u=r),n[0]=c*s+u*d,n[1]=c*l+u*m,n[2]=c*f+u*_,n[3]=c*h+u*v,n}function Rr(n,t){let e=t[0],r=t[1],i=t[2],o=t[3],a=e*e+r*r+i*i+o*o,c=a?1/a:0;return n[0]=-e*c,n[1]=-r*c,n[2]=-i*c,n[3]=o*c,n}function Pr(n,t){return n[0]=-t[0],n[1]=-t[1],n[2]=-t[2],n[3]=t[3],n}function Nr(n,t){let e,r=t[0]+t[4]+t[8];if(r>0)e=Math.sqrt(r+1),n[3]=.5*e,e=.5/e,n[0]=(t[5]-t[7])*e,n[1]=(t[6]-t[2])*e,n[2]=(t[1]-t[3])*e;else{let r=0;t[4]>t[0]&&(r=1),t[8]>t[3*r+r]&&(r=2);let i=(r+1)%3,o=(r+2)%3;e=Math.sqrt(t[3*r+r]-t[3*i+i]-t[3*o+o]+1),n[r]=.5*e,e=.5/e,n[3]=(t[3*i+o]-t[3*o+i])*e,n[i]=(t[3*i+r]+t[3*r+i])*e,n[o]=(t[3*o+r]+t[3*r+o])*e}return n}function Ar(n,t,e,r){let i=.5*Math.PI/180;t*=i,e*=i,r*=i;let o=Math.sin(t),a=Math.cos(t),c=Math.sin(e),u=Math.cos(e),s=Math.sin(r),l=Math.cos(r);return n[0]=o*u*l-a*c*s,n[1]=a*c*l+o*u*s,n[2]=a*u*s-o*c*l,n[3]=a*u*l+o*c*s,n}function Or(n){return"quat("+n[0]+", "+n[1]+", "+n[2]+", "+n[3]+")"}const zr=Fe,Fr=qe,qr=De,Dr=Ce,Cr=Ge,Gr=br,Hr=Xe,Ur=rr,Br=ir,Zr=Je,Vr=Zr,kr=$e,Yr=kr,jr=er,Xr=sr,Wr=lr,Kr=function(){let n=Ut(),t=Vt(1,0,0),e=Vt(0,1,0);return function(r,i,o){let a=le(i,o);return a<-.999999?(fe(n,t,i),Ne(n)<1e-6&&fe(n,e,i),se(n,n),Ir(r,n,Math.PI),r):a>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(fe(n,i,o),r[0]=n[0],r[1]=n[1],r[2]=n[2],r[3]=1+a,jr(r,r))}}(),Qr=function(){let n=xr(),t=xr();return function(e,r,i,o,a,c){return Tr(n,r,a,c),Tr(t,i,o,c),Tr(e,n,t,2*c*(1-c)),e}}(),Jr=function(){let n=gn();return function(t,e,r,i){return n[0]=r[0],n[3]=r[1],n[6]=r[2],n[1]=i[0],n[4]=i[1],n[7]=i[2],n[2]=-e[0],n[5]=-e[1],n[8]=-e[2],jr(t,Nr(t,n))}}();function $r(){let n=new d(2);return n[0]=0,n[1]=0,n}function ni(n){let t=new d(2);return t[0]=n[0],t[1]=n[1],t}function ti(n,t){let e=new d(2);return e[0]=n,e[1]=t,e}function ei(n,t){return n[0]=t[0],n[1]=t[1],n}function ri(n,t,e){return n[0]=t,n[1]=e,n}function ii(n,t,e){return n[0]=t[0]+e[0],n[1]=t[1]+e[1],n}function oi(n,t,e){return n[0]=t[0]-e[0],n[1]=t[1]-e[1],n}function ai(n,t,e){return n[0]=t[0]*e[0],n[1]=t[1]*e[1],n}function ci(n,t,e){return n[0]=t[0]/e[0],n[1]=t[1]/e[1],n}function ui(n,t){return n[0]=Math.ceil(t[0]),n[1]=Math.ceil(t[1]),n}function si(n,t){return n[0]=Math.floor(t[0]),n[1]=Math.floor(t[1]),n}function li(n,t,e){return n[0]=Math.min(t[0],e[0]),n[1]=Math.min(t[1],e[1]),n}function fi(n,t,e){return n[0]=Math.max(t[0],e[0]),n[1]=Math.max(t[1],e[1]),n}function hi(n,t){return n[0]=Math.round(t[0]),n[1]=Math.round(t[1]),n}function di(n,t,e){return n[0]=t[0]*e,n[1]=t[1]*e,n}function mi(n,t,e,r){return n[0]=t[0]+e[0]*r,n[1]=t[1]+e[1]*r,n}function _i(n,t){var e=t[0]-n[0],r=t[1]-n[1];return Math.sqrt(e*e+r*r)}function vi(n,t){var e=t[0]-n[0],r=t[1]-n[1];return e*e+r*r}function gi(n){var t=n[0],e=n[1];return Math.sqrt(t*t+e*e)}function Mi(n){var t=n[0],e=n[1];return t*t+e*e}function xi(n,t){return n[0]=-t[0],n[1]=-t[1],n}function pi(n,t){return n[0]=1/t[0],n[1]=1/t[1],n}function Ii(n,t){var e=t[0],r=t[1],i=e*e+r*r;return i>0&&(i=1/Math.sqrt(i),n[0]=t[0]*i,n[1]=t[1]*i),n}function Ei(n,t){return n[0]*t[0]+n[1]*t[1]}function bi(n,t,e){var r=t[0]*e[1]-t[1]*e[0];return n[0]=n[1]=0,n[2]=r,n}function Si(n,t,e,r){var i=t[0],o=t[1];return n[0]=i+r*(e[0]-i),n[1]=o+r*(e[1]-o),n}function yi(n,t){t=t||1;var e=2*m()*Math.PI;return n[0]=Math.cos(e)*t,n[1]=Math.sin(e)*t,n}function wi(n,t,e){var r=t[0],i=t[1];return n[0]=e[0]*r+e[2]*i,n[1]=e[1]*r+e[3]*i,n}function Li(n,t,e){var r=t[0],i=t[1];return n[0]=e[0]*r+e[2]*i+e[4],n[1]=e[1]*r+e[3]*i+e[5],n}function Ti(n,t,e){var r=t[0],i=t[1];return n[0]=e[0]*r+e[3]*i+e[6],n[1]=e[1]*r+e[4]*i+e[7],n}function Ri(n,t,e){let r=t[0],i=t[1];return n[0]=e[0]*r+e[4]*i+e[12],n[1]=e[1]*r+e[5]*i+e[13],n}function Pi(n){return"vec2("+n[0]+", "+n[1]+")"}function Ni(n,t){return n[0]===t[0]&&n[1]===t[1]}function Ai(n,t){let e=n[0],r=n[1],i=t[0],o=t[1];return Math.abs(e-i)<=h*Math.max(1,Math.abs(e),Math.abs(i))&&Math.abs(r-o)<=h*Math.max(1,Math.abs(r),Math.abs(o))}const Oi=gi,zi=oi,Fi=ai,qi=ci,Di=_i,Ci=vi,Gi=Mi,Hi=function(){let n=$r();return function(t,e,r,i,o,a){let c,u;for(e||(e=2),r||(r=0),u=i?Math.min(i*e+r,t.length):t.length,c=r;c<u;c+=e)n[0]=t[c],n[1]=t[c+1],o(n,n,a),t[c]=n[0],t[c+1]=n[1];return t}}();e.d(t,"glMatrix",function(){return r}),e.d(t,"mat2",function(){return i}),e.d(t,"mat2d",function(){return o}),e.d(t,"mat3",function(){return a}),e.d(t,"mat4",function(){return c}),e.d(t,"quat",function(){return l}),e.d(t,"vec2",function(){return f}),e.d(t,"vec3",function(){return u}),e.d(t,"vec4",function(){return s})},2:function(n,t,e){"use strict"},39:function(n,t){n.exports="\nprecision mediump float;\nprecision mediump usampler2D;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n    #extension GL_OES_standard_derivatives : enable\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nconst int NUM_TRIANGLES = 30;\nconst int NUM_VERTICES = 24;\nconst int NUM_COLORS = 5;\n\nconst float vertices[NUM_VERTICES * 3] = float[NUM_VERTICES * 3]\n(   // room\n    -1.000000, -1.000000, -1.000000, -1.000000, -1.000000, +1.000000,\n    -1.000000, +1.000000, -1.000000, -1.000000, +1.000000, +1.000000,\n    +0.988489, -1.000000, -1.000000, +0.976978, -1.000000, +1.000000,\n    +1.000000, +1.000000, -1.000000, +1.000000, +1.000000, +1.000000,\n    // short block\n    +0.043165, -1.000000, -0.592275, +0.043165, -0.398688, -0.592275,\n    -0.136691, -1.000000, -0.027182, -0.136691, -0.398688, -0.027182,\n    -0.705036, -1.000000, -0.195279, -0.705036, -0.398688, -0.195279,\n    -0.532374, -1.000000, -0.767525, -0.532374, -0.398688, -0.767525,\n    // tall block\n    +0.521583, -1.000000, -0.116595, +0.521583, +0.202624, -0.116595,\n    +0.697842, -1.000000, +0.452074, +0.697842, +0.202624, +0.452074,\n    +0.129496, -1.000000, +0.630901, +0.129496, +0.202624, +0.630901,\n    -0.046763, -1.000000, +0.058655, -0.046763, +0.202624, +0.058655\n);\n\n// v0, v1, v2, color\nconst int indices[NUM_TRIANGLES * 4] = int[NUM_TRIANGLES * 4]\n(\n    // room ceiling\n    6, 7, 3, 1,\n    6, 3, 2, 1,\n    // room floor\n    4, 0, 1, 1,\n    4, 1, 5, 1,\n    // room front wall\n    // 6, 2, 0, 1,\n    // 6, 0, 4, 1,\n    // room back wall\n    5, 1, 3, 1,\n    5, 3, 7, 1,\n    // room right wall\n    1, 0, 2, 3,\n    1, 2, 3, 3,\n    // room left wall\n    4, 5, 7, 2,\n    4, 7, 6, 2,\n    // short block\n    15, 13, 11, 1,\n    15, 11,  9, 1,\n     8,  9, 11, 1,\n     8, 11, 10, 1,\n    14, 15,  9, 1,\n    14,  9,  8, 1,\n    12, 13, 15, 1,\n    12, 15, 14, 1,\n    10, 11, 13, 1,\n    10, 13, 12, 1,\n    // tall block\n    23, 21, 19, 1,\n    23, 19, 17, 1,\n    16, 17, 19, 1,\n    16, 19, 18, 1,\n    22, 23, 17, 1,\n    22, 17, 16, 1,\n    20, 21, 23, 1,\n    20, 23, 22, 1,\n    18, 19, 21, 1,\n    18, 21, 20, 1\n);\n\nconst float colors[NUM_COLORS * 3] = float[NUM_COLORS * 3]\n(\n    0.0000, 0.0000, 0.0000,  // 0 black\n    0.7295, 0.7355, 0.7290,  // 1 white\n    0.6110, 0.0555, 0.0620,  // 2 red\n    0.1170, 0.4125, 0.1150,  // 3 green\n    0.0620, 0.0555, 0.6110   // 4 blue\n);\n\n\nuniform sampler2D u_hsphere;\nuniform sampler2D u_lights;\nconst vec2 SPHERE_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_hsphere, 0);\nconst vec2 LIGHT_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_lights, 0);\n\n\nvec3 vertexFetch(const in float index) {\n    return vec3(\n        vertices[int(round(index)) * 3 + 0],\n        vertices[int(round(index)) * 3 + 1],\n        vertices[int(round(index)) * 3 + 2]\n    );\n}\n\nvec4 indexFetch(const in float index) {\n    return vec4(\n        indices[int(round(index)) * 4 + 0],\n        indices[int(round(index)) * 4 + 1],\n        indices[int(round(index)) * 4 + 2],\n        indices[int(round(index)) * 4 + 3]\n    );\n}\n\nvec3 colorFetch(const in float index) {\n    return vec3(\n        colors[int(round(index)) * 3 + 0],\n        colors[int(round(index)) * 3 + 1],\n        colors[int(round(index)) * 3 + 2]\n    );\n}\n\nvec3 hsphereFetch(const in vec2 index) {\n    return texture(u_hsphere, index / (SPHERE_SAMPLER_SIZE-1.0)).xyz;\n}\n\nvec3 lightFetch(const in vec2 index) {\n    return texture(u_lights, index / (LIGHT_SAMPLER_SIZE-1.0)).xyz;\n}\n\n\n\n/*\nneeds version specific stuff:\nlayout(location = 0) out vec4 fragColor;\n\nconst float NUM_TRIANGLES\nconst vec2 SPHERE_SAMPLER_SIZE\nconst vec2 LIGHT_SAMPLER_SIZE\n\n// functions to access the static data (vertices, indices, colors, hsphere samples, light samples):\nvec3 vertexFetch(const in float index) {}\nvec4 indexFetch(const in float index) {}\nvec3 colorFetch(const in float index) {}\nvec3 hsphereFetch(const in vec2 index) {}\nvec3 lightFetch(const in vec2 index) {}\n*/\n\nuniform int u_frame;\nuniform int u_rand;\nuniform vec3 u_eye;\nuniform vec4 u_viewport;\n\nvarying vec2 v_uv;\nvarying vec4 v_ray;\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec4 SPHERE = vec4(-0.5, +0.0, +0.5, 0.25); // center, radius\nconst vec3 LIGHT_COLOR = vec3(1.0, 10.76 / 16.86, 3.7 / 16.86);\n\nconst float EPSILON  = 1e-6;\nconst float INFINITY = 1e+4;\n\nconst int BOUNCES = 4;\nconst float EXPOSURE = 4.0;\nconst float GAMMA = 2.1;\n\n\n\n// intersection with triangle\nbool intersectionTriangle(\n\tconst in vec3  triangle[3]\n,\tconst in vec3  origin\n,\tconst in vec3  ray\n,\tconst in float t_min\n,   out float t)\n{\n    vec3 e0 = triangle[1] - triangle[0];\n\tvec3 e1 = triangle[2] - triangle[0];\n\n\tvec3  h = cross(ray, e1);\n\tfloat a = dot(e0, h);\n\n\t// if(a > -EPSILON && a < EPSILON) // backface culling off\n\tif(a < EPSILON) // backface culling on\n\t\treturn false;\n\n\tfloat f = 1.0 / a;\n\n\tvec3  s = origin - triangle[0];\n\tfloat u = f * dot(s, h);\n\n\tif(u < 0.0 || u > 1.0)\n\t\treturn false;\n\n\tvec3  q = cross(s, e0);\n\tfloat v = f * dot(ray, q);\n\n\tif(v < 0.0 || u + v > 1.0)\n\t\treturn false;\n\n\tt = f * dot(e1, q);\n\n\treturn EPSILON < t && t < t_min;\n}\n\nbool intersectionSphere(\n    const in vec4  sphere\n,   const in vec3  origin\n,   const in vec3  ray\n,   const in float t_min\n,   out float t)\n{\n    float radius = sphere.w;\n    vec3 center = sphere.xyz; \n    vec3 rayOriginToSphereCenter = origin - center;\n    float dist = length(rayOriginToSphereCenter);\n    float dot_term = dot(ray, rayOriginToSphereCenter);\n    float someVar = dot_term * dot_term - dist * dist + radius * radius;\n    if (someVar < EPSILON) { // no intersection\n        return false;\n    }\n    t = -dot_term - sqrt(someVar);\n    return EPSILON < t && t < t_min;\n}\n\n// intersection with scene geometry\nfloat intersection(\n    const in vec3 origin\n,   const in vec3 ray\n,   out vec3 normal\n,   out vec3 color\n,   out bool reflecting)\n{\n    float t_min = INFINITY;\n    float t = INFINITY;\n\n    float colorIndex;\n\n    // intersection with triangles\n\tfor(int i = 0; i < int(NUM_TRIANGLES); ++i)\n\t{\n        vec3 triangle[3];\n        vec4 triangleIndices = indexFetch(float(i));\n\t\ttriangle[0] = vertexFetch(triangleIndices[0]);\n\t\ttriangle[1] = vertexFetch(triangleIndices[1]);\n\t\ttriangle[2] = vertexFetch(triangleIndices[2]);\n\n\t\tif(intersectionTriangle(triangle, origin, ray, t_min, t))\n\t\t{\n\t\t\tnormal = normalize(cross(\n                triangle[1] - triangle[0],\n                triangle[2] - triangle[0]\n            ));\n\t\t\tcolorIndex = triangleIndices[3];\n\t\t\tt_min = t;\n            reflecting = colorIndex == 5.0;\n\t\t}\n\t}\n\n    // intersection with sphere\n    if(intersectionSphere(SPHERE, origin, ray, t_min, t))\n    {\n        vec3 intersectionPoint = origin + ray*t;\n        normal = normalize(intersectionPoint - SPHERE.xyz);\n        colorIndex = 4.0;\n        t_min = t;\n        reflecting = true;\n    }\n\n    color = colorFetch(colorIndex);\n\n    return t_min;\n}\n\nvec3 randomPointOnHemisphere(const in int fragID)\n{\n\tfloat i = mod(float(fragID), (SPHERE_SAMPLER_SIZE[0] * SPHERE_SAMPLER_SIZE[1]));\n\n    float x = mod(i, SPHERE_SAMPLER_SIZE[0]);\n    float y = i / SPHERE_SAMPLER_SIZE[0];\n\n\treturn hsphereFetch(vec2(x,y));\n}\n\nvec3 randomPointInLight(const in int fragID)\n{\n\tfloat i = mod(float(fragID), LIGHT_SAMPLER_SIZE[0] * LIGHT_SAMPLER_SIZE[1]);\n\n    float x = mod(i, LIGHT_SAMPLER_SIZE[0]);\n    float y = i / LIGHT_SAMPLER_SIZE[0];\n\n\treturn lightFetch(vec2(x,y));\n}\n\n// intersection with scene geometry\nfloat shadow(\n\tconst in int fragID\n,\tconst in vec3 origin\n,\tconst in vec3 normal\n,   out float sqDistToLight)\n{\n    vec3 pointInLight = randomPointInLight(fragID);\n    float distToLight = distance(pointInLight, origin);\n\n\tvec3 ray_direction = normalize(pointInLight - origin);\n\n\tfloat a = dot(ray_direction, normal);\n\tif(a < EPSILON)\n\t \treturn 0.0;\n\n    vec3 v1,v2; bool r; // unused\n    float dist = intersection(origin, ray_direction, v1, v2, r);\n    if(EPSILON < dist && dist <= distToLight)\n        return 0.0;\n        \n    sqDistToLight = distToLight * distToLight;\n\treturn a;\n}\n\nmat3 computeTbn(in vec3 normal)\n{\n    vec3 arbNormal = vec3(-1.241284e-02, -7.011432e-01, +2.043006e-01);\n    arbNormal = mix(arbNormal, vec3(+2.019038e-01, +9.717299e-01, +1.223763e-01), \n        step(0.0, abs(dot(arbNormal, normal))));\n\n    vec3 e0 = cross(arbNormal, normal);\n\tvec3 e1 = cross(e0, normal);\n\n    return mat3(e0, normal, e1);\n}\n\n// http://gpupathtracer.blogspot.de/\n// http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\n// http://undernones.blogspot.de/2010/12/gpu-ray-tracing-with-glsl.html\n// http://www.iquilezles.org/www/articles/simplegpurt/simplegpurt.htm\n// http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/\n\nvoid main()\n{\n    vec3 ray_origin = u_eye;\n    vec3 ray_direction = normalize((v_ray.xyz / v_ray.w) - ray_origin);\n\n    // fragment index for random variation\n\tvec2 xy = v_uv * vec2(u_viewport[0], u_viewport[1]);\n\tint fragID = int(xy.y * u_viewport[0] + xy.x + float(u_frame) + float(u_rand));\n\n\t// path color accumulation\n\tvec3 maskColor = vec3(1.0);\n\tvec3 pathColor = vec3(0.0);\n\n    // fragment is transparent before any intersection\n    float alpha = 0.0;\n\n\tfor(int bounce = 0; bounce < BOUNCES; ++bounce)\n\t{\n        // check intersection with scene geometry\n        vec3 normal;\n        vec3 color;\n        bool reflecting;\n        float dist = intersection(ray_origin, ray_direction, normal, color, reflecting); \n\n        if(dist == INFINITY)\n            break; // TODO: break on no intersection, with correct path color weight?\n\n        // update ray for next bounce\n        ray_origin = ray_origin + ray_direction * dist;\n        if(reflecting){\n            ray_direction = reflect(ray_direction, normal);\n            if(bounce == 0) {\n                alpha = 1.0;\n            }\n            continue;\n        }\n        ray_direction = computeTbn(normal) * randomPointOnHemisphere(fragID + bounce);\n\n        // compute lighting and color\n        alpha = 1.0;\n        float squaredDistToLight = 1.0;\n  \t\tfloat lighting = shadow(fragID + bounce, ray_origin, normal, squaredDistToLight);\n  \t    maskColor *= color;\n  \t\tpathColor += maskColor * LIGHT_COLOR * lighting / squaredDistToLight;\n    }\n\n    fragColor = vec4(pow(EXPOSURE * pathColor, vec3(1.0 / GAMMA)), alpha);\n}\n\n"},40:function(n,t){n.exports="\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n    #extension GL_OES_standard_derivatives : enable\n    precision mediump float;\n#else\n    precision mediump float;\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nuniform sampler2D u_vertices; // 1D\nuniform sampler2D u_indices;  // 1D\nuniform sampler2D u_colors;   // 1D\nconst float NUM_VERTICES = 24.0;\nconst float NUM_TRIANGLES = 30.0;\nconst float NUM_COLORS = 5.0;\n\nuniform sampler2D u_hsphere;\nuniform sampler2D u_lights;\nconst vec2 SPHERE_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_hsphere, 0);\nconst vec2 LIGHT_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_lights, 0);\n\n\nconst vec3 premultUint8x3 = vec3(255.0 / 256.0, 255.0 / 65536.0, 255.0 / 16777216.0);\nfloat uint8x3_to_float24x1(const in vec3 v) {\n    return dot(v, premultUint8x3); // a1 * b1 + a2 * b2 + a3 * b3  ;)\n}\n\nvec3 vertexFetch(const in float index) {\n    // *3 because every vertex has 3 floats\n    float realIndex = index * 3.0;\n    // one lookup for each float; a float is encoded in 3 bytes (xyz)\n    vec2 floatIndex1 = vec2((realIndex      ) / (NUM_VERTICES* 3.0 - 1.0), 0);\n    vec2 floatIndex2 = vec2((realIndex + 1.0) / (NUM_VERTICES* 3.0 - 1.0), 0);\n    vec2 floatIndex3 = vec2((realIndex + 2.0) / (NUM_VERTICES* 3.0 - 1.0), 0);\n    // read and scale from [0..1] to [-1..+1]\n    float x = uint8x3_to_float24x1(texture(u_vertices, floatIndex1).xyz) * 2.0 - 1.0;\n    float y = uint8x3_to_float24x1(texture(u_vertices, floatIndex2).xyz) * 2.0 - 1.0;\n    float z = uint8x3_to_float24x1(texture(u_vertices, floatIndex3).xyz) * 2.0 - 1.0;\n\n    return vec3(x,y,z);\n}\n\nvec4 indexFetch(const in float index) {\n    // * 255 because openGL scales to [0..1]\n    return texture(u_indices, vec2(index / (NUM_TRIANGLES-1.0), 0)) * 255.0;\n}\n\nvec3 colorFetch(const in float index) {\n    // *3 because every color has 3 floats\n    float realIndex = index * 3.0;\n    // one lookup for each float; a float is encoded in 3 bytes (xyz)\n    vec2 floatIndex1 = vec2((realIndex      ) / (NUM_COLORS* 3.0 - 1.0), 0);\n    vec2 floatIndex2 = vec2((realIndex + 1.0) / (NUM_COLORS* 3.0 - 1.0), 0);\n    vec2 floatIndex3 = vec2((realIndex + 2.0) / (NUM_COLORS* 3.0 - 1.0), 0);\n\n    float x = uint8x3_to_float24x1(texture(u_colors, floatIndex1).xyz);\n    float y = uint8x3_to_float24x1(texture(u_colors, floatIndex2).xyz);\n    float z = uint8x3_to_float24x1(texture(u_colors, floatIndex3).xyz);\n\n    return vec3(x,y,z);\n}\n\nvec3 hsphereFetch(const in vec2 index) {\n    // *3 because every vector has 3 floats\n    vec2 realIndex = vec2(index.x * 3.0, index.y);\n    // one lookup for each float; a float is encoded in 3 bytes (xyz)\n    vec2 floatIndex1 = vec2((realIndex.x      ), realIndex.y) / (SPHERE_SAMPLER_SIZE * 3.0 - 1.0);\n    vec2 floatIndex2 = vec2((realIndex.x + 1.0), realIndex.y) / (SPHERE_SAMPLER_SIZE * 3.0 - 1.0);\n    vec2 floatIndex3 = vec2((realIndex.x + 2.0), realIndex.y) / (SPHERE_SAMPLER_SIZE * 3.0 - 1.0);\n\n    float x = uint8x3_to_float24x1(texture(u_hsphere, floatIndex1).xyz) * 2.0 - 1.0;\n    float y = uint8x3_to_float24x1(texture(u_hsphere, floatIndex2).xyz) * 2.0 - 1.0;\n    float z = uint8x3_to_float24x1(texture(u_hsphere, floatIndex3).xyz) * 2.0 - 1.0;\n\n    return vec3(x,y,z);\n}\n\nvec3 lightFetch(const in vec2 index) {\n    // *3 because every vector has 3 floats\n    vec2 realIndex = vec2(index.x * 3.0, index.y);\n    // one lookup for each float; a float is encoded in 3 bytes (xyz)\n    vec2 floatIndex1 = vec2((realIndex.x      ), realIndex.y) / (LIGHT_SAMPLER_SIZE * 3.0 - 1.0);\n    vec2 floatIndex2 = vec2((realIndex.x + 1.0), realIndex.y) / (LIGHT_SAMPLER_SIZE * 3.0 - 1.0);\n    vec2 floatIndex3 = vec2((realIndex.x + 2.0), realIndex.y) / (LIGHT_SAMPLER_SIZE * 3.0 - 1.0);\n    // read and scale from [0..1] to [-1..+1]\n    float x = uint8x3_to_float24x1(texture(u_lights, floatIndex1).xyz) * 2.0 - 1.0;\n    float y = uint8x3_to_float24x1(texture(u_lights, floatIndex2).xyz) * 2.0 - 1.0;\n    float z = uint8x3_to_float24x1(texture(u_lights, floatIndex3).xyz) * 2.0 - 1.0;\n\n    return vec3(x,y,z);\n}\n\n\n\n/*\nneeds version specific stuff:\nlayout(location = 0) out vec4 fragColor;\n\nconst float NUM_TRIANGLES\nconst vec2 SPHERE_SAMPLER_SIZE\nconst vec2 LIGHT_SAMPLER_SIZE\n\n// functions to access the static data (vertices, indices, colors, hsphere samples, light samples):\nvec3 vertexFetch(const in float index) {}\nvec4 indexFetch(const in float index) {}\nvec3 colorFetch(const in float index) {}\nvec3 hsphereFetch(const in vec2 index) {}\nvec3 lightFetch(const in vec2 index) {}\n*/\n\nuniform int u_frame;\nuniform int u_rand;\nuniform vec3 u_eye;\nuniform vec4 u_viewport;\n\nvarying vec2 v_uv;\nvarying vec4 v_ray;\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec4 SPHERE = vec4(-0.5, +0.0, +0.5, 0.25); // center, radius\nconst vec3 LIGHT_COLOR = vec3(1.0, 10.76 / 16.86, 3.7 / 16.86);\n\nconst float EPSILON  = 1e-6;\nconst float INFINITY = 1e+4;\n\nconst int BOUNCES = 4;\nconst float EXPOSURE = 4.0;\nconst float GAMMA = 2.1;\n\n\n\n// intersection with triangle\nbool intersectionTriangle(\n\tconst in vec3  triangle[3]\n,\tconst in vec3  origin\n,\tconst in vec3  ray\n,\tconst in float t_min\n,   out float t)\n{\n    vec3 e0 = triangle[1] - triangle[0];\n\tvec3 e1 = triangle[2] - triangle[0];\n\n\tvec3  h = cross(ray, e1);\n\tfloat a = dot(e0, h);\n\n\t// if(a > -EPSILON && a < EPSILON) // backface culling off\n\tif(a < EPSILON) // backface culling on\n\t\treturn false;\n\n\tfloat f = 1.0 / a;\n\n\tvec3  s = origin - triangle[0];\n\tfloat u = f * dot(s, h);\n\n\tif(u < 0.0 || u > 1.0)\n\t\treturn false;\n\n\tvec3  q = cross(s, e0);\n\tfloat v = f * dot(ray, q);\n\n\tif(v < 0.0 || u + v > 1.0)\n\t\treturn false;\n\n\tt = f * dot(e1, q);\n\n\treturn EPSILON < t && t < t_min;\n}\n\nbool intersectionSphere(\n    const in vec4  sphere\n,   const in vec3  origin\n,   const in vec3  ray\n,   const in float t_min\n,   out float t)\n{\n    float radius = sphere.w;\n    vec3 center = sphere.xyz; \n    vec3 rayOriginToSphereCenter = origin - center;\n    float dist = length(rayOriginToSphereCenter);\n    float dot_term = dot(ray, rayOriginToSphereCenter);\n    float someVar = dot_term * dot_term - dist * dist + radius * radius;\n    if (someVar < EPSILON) { // no intersection\n        return false;\n    }\n    t = -dot_term - sqrt(someVar);\n    return EPSILON < t && t < t_min;\n}\n\n// intersection with scene geometry\nfloat intersection(\n    const in vec3 origin\n,   const in vec3 ray\n,   out vec3 normal\n,   out vec3 color\n,   out bool reflecting)\n{\n    float t_min = INFINITY;\n    float t = INFINITY;\n\n    float colorIndex;\n\n    // intersection with triangles\n\tfor(int i = 0; i < int(NUM_TRIANGLES); ++i)\n\t{\n        vec3 triangle[3];\n        vec4 triangleIndices = indexFetch(float(i));\n\t\ttriangle[0] = vertexFetch(triangleIndices[0]);\n\t\ttriangle[1] = vertexFetch(triangleIndices[1]);\n\t\ttriangle[2] = vertexFetch(triangleIndices[2]);\n\n\t\tif(intersectionTriangle(triangle, origin, ray, t_min, t))\n\t\t{\n\t\t\tnormal = normalize(cross(\n                triangle[1] - triangle[0],\n                triangle[2] - triangle[0]\n            ));\n\t\t\tcolorIndex = triangleIndices[3];\n\t\t\tt_min = t;\n            reflecting = colorIndex == 5.0;\n\t\t}\n\t}\n\n    // intersection with sphere\n    if(intersectionSphere(SPHERE, origin, ray, t_min, t))\n    {\n        vec3 intersectionPoint = origin + ray*t;\n        normal = normalize(intersectionPoint - SPHERE.xyz);\n        colorIndex = 4.0;\n        t_min = t;\n        reflecting = true;\n    }\n\n    color = colorFetch(colorIndex);\n\n    return t_min;\n}\n\nvec3 randomPointOnHemisphere(const in int fragID)\n{\n\tfloat i = mod(float(fragID), (SPHERE_SAMPLER_SIZE[0] * SPHERE_SAMPLER_SIZE[1]));\n\n    float x = mod(i, SPHERE_SAMPLER_SIZE[0]);\n    float y = i / SPHERE_SAMPLER_SIZE[0];\n\n\treturn hsphereFetch(vec2(x,y));\n}\n\nvec3 randomPointInLight(const in int fragID)\n{\n\tfloat i = mod(float(fragID), LIGHT_SAMPLER_SIZE[0] * LIGHT_SAMPLER_SIZE[1]);\n\n    float x = mod(i, LIGHT_SAMPLER_SIZE[0]);\n    float y = i / LIGHT_SAMPLER_SIZE[0];\n\n\treturn lightFetch(vec2(x,y));\n}\n\n// intersection with scene geometry\nfloat shadow(\n\tconst in int fragID\n,\tconst in vec3 origin\n,\tconst in vec3 normal\n,   out float sqDistToLight)\n{\n    vec3 pointInLight = randomPointInLight(fragID);\n    float distToLight = distance(pointInLight, origin);\n\n\tvec3 ray_direction = normalize(pointInLight - origin);\n\n\tfloat a = dot(ray_direction, normal);\n\tif(a < EPSILON)\n\t \treturn 0.0;\n\n    vec3 v1,v2; bool r; // unused\n    float dist = intersection(origin, ray_direction, v1, v2, r);\n    if(EPSILON < dist && dist <= distToLight)\n        return 0.0;\n        \n    sqDistToLight = distToLight * distToLight;\n\treturn a;\n}\n\nmat3 computeTbn(in vec3 normal)\n{\n    vec3 arbNormal = vec3(-1.241284e-02, -7.011432e-01, +2.043006e-01);\n    arbNormal = mix(arbNormal, vec3(+2.019038e-01, +9.717299e-01, +1.223763e-01), \n        step(0.0, abs(dot(arbNormal, normal))));\n\n    vec3 e0 = cross(arbNormal, normal);\n\tvec3 e1 = cross(e0, normal);\n\n    return mat3(e0, normal, e1);\n}\n\n// http://gpupathtracer.blogspot.de/\n// http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\n// http://undernones.blogspot.de/2010/12/gpu-ray-tracing-with-glsl.html\n// http://www.iquilezles.org/www/articles/simplegpurt/simplegpurt.htm\n// http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/\n\nvoid main()\n{\n    vec3 ray_origin = u_eye;\n    vec3 ray_direction = normalize((v_ray.xyz / v_ray.w) - ray_origin);\n\n    // fragment index for random variation\n\tvec2 xy = v_uv * vec2(u_viewport[0], u_viewport[1]);\n\tint fragID = int(xy.y * u_viewport[0] + xy.x + float(u_frame) + float(u_rand));\n\n\t// path color accumulation\n\tvec3 maskColor = vec3(1.0);\n\tvec3 pathColor = vec3(0.0);\n\n    // fragment is transparent before any intersection\n    float alpha = 0.0;\n\n\tfor(int bounce = 0; bounce < BOUNCES; ++bounce)\n\t{\n        // check intersection with scene geometry\n        vec3 normal;\n        vec3 color;\n        bool reflecting;\n        float dist = intersection(ray_origin, ray_direction, normal, color, reflecting); \n\n        if(dist == INFINITY)\n            break; // TODO: break on no intersection, with correct path color weight?\n\n        // update ray for next bounce\n        ray_origin = ray_origin + ray_direction * dist;\n        if(reflecting){\n            ray_direction = reflect(ray_direction, normal);\n            if(bounce == 0) {\n                alpha = 1.0;\n            }\n            continue;\n        }\n        ray_direction = computeTbn(normal) * randomPointOnHemisphere(fragID + bounce);\n\n        // compute lighting and color\n        alpha = 1.0;\n        float squaredDistToLight = 1.0;\n  \t\tfloat lighting = shadow(fragID + bounce, ray_origin, normal, squaredDistToLight);\n  \t    maskColor *= color;\n  \t\tpathColor += maskColor * LIGHT_COLOR * lighting / squaredDistToLight;\n    }\n\n    fragColor = vec4(pow(EXPOSURE * pathColor, vec3(1.0 / GAMMA)), alpha);\n}\n\n"},41:function(n,t){n.exports="\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n    #extension GL_OES_standard_derivatives : enable\n    precision mediump float;\n#else\n    precision mediump float;\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nuniform sampler2D u_vertices; // 1D\nuniform sampler2D u_indices;  // 1D\nuniform sampler2D u_colors;   // 1D\nconst float NUM_VERTICES = 24.0;\nconst float NUM_TRIANGLES = 30.0;\nconst float NUM_COLORS = 5.0;\n\nuniform sampler2D u_hsphere;\nuniform sampler2D u_lights;\nconst vec2 SPHERE_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_hsphere, 0);\nconst vec2 LIGHT_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_lights, 0);\n\n\nvec3 vertexFetch(const in float index) {\n    return texture(u_vertices, vec2(index / (NUM_VERTICES-1.0), 0)).xyz;\n}\n\nvec4 indexFetch(const in float index) {\n    return texture(u_indices, vec2(index / (NUM_TRIANGLES-1.0), 0)) * 255.0;\n}\n\nvec3 colorFetch(const in float index) {\n    return texture(u_colors, vec2(index / (NUM_COLORS-1.0), 0)).xyz;\n}\n\nvec3 hsphereFetch(const in vec2 index) {\n    return texture(u_hsphere, index / (SPHERE_SAMPLER_SIZE-1.0)).xyz;\n}\n\nvec3 lightFetch(const in vec2 index) {\n    return texture(u_lights, index / (LIGHT_SAMPLER_SIZE-1.0)).xyz;\n}\n\n\n\n/*\nneeds version specific stuff:\nlayout(location = 0) out vec4 fragColor;\n\nconst float NUM_TRIANGLES\nconst vec2 SPHERE_SAMPLER_SIZE\nconst vec2 LIGHT_SAMPLER_SIZE\n\n// functions to access the static data (vertices, indices, colors, hsphere samples, light samples):\nvec3 vertexFetch(const in float index) {}\nvec4 indexFetch(const in float index) {}\nvec3 colorFetch(const in float index) {}\nvec3 hsphereFetch(const in vec2 index) {}\nvec3 lightFetch(const in vec2 index) {}\n*/\n\nuniform int u_frame;\nuniform int u_rand;\nuniform vec3 u_eye;\nuniform vec4 u_viewport;\n\nvarying vec2 v_uv;\nvarying vec4 v_ray;\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec4 SPHERE = vec4(-0.5, +0.0, +0.5, 0.25); // center, radius\nconst vec3 LIGHT_COLOR = vec3(1.0, 10.76 / 16.86, 3.7 / 16.86);\n\nconst float EPSILON  = 1e-6;\nconst float INFINITY = 1e+4;\n\nconst int BOUNCES = 4;\nconst float EXPOSURE = 4.0;\nconst float GAMMA = 2.1;\n\n\n\n// intersection with triangle\nbool intersectionTriangle(\n\tconst in vec3  triangle[3]\n,\tconst in vec3  origin\n,\tconst in vec3  ray\n,\tconst in float t_min\n,   out float t)\n{\n    vec3 e0 = triangle[1] - triangle[0];\n\tvec3 e1 = triangle[2] - triangle[0];\n\n\tvec3  h = cross(ray, e1);\n\tfloat a = dot(e0, h);\n\n\t// if(a > -EPSILON && a < EPSILON) // backface culling off\n\tif(a < EPSILON) // backface culling on\n\t\treturn false;\n\n\tfloat f = 1.0 / a;\n\n\tvec3  s = origin - triangle[0];\n\tfloat u = f * dot(s, h);\n\n\tif(u < 0.0 || u > 1.0)\n\t\treturn false;\n\n\tvec3  q = cross(s, e0);\n\tfloat v = f * dot(ray, q);\n\n\tif(v < 0.0 || u + v > 1.0)\n\t\treturn false;\n\n\tt = f * dot(e1, q);\n\n\treturn EPSILON < t && t < t_min;\n}\n\nbool intersectionSphere(\n    const in vec4  sphere\n,   const in vec3  origin\n,   const in vec3  ray\n,   const in float t_min\n,   out float t)\n{\n    float radius = sphere.w;\n    vec3 center = sphere.xyz; \n    vec3 rayOriginToSphereCenter = origin - center;\n    float dist = length(rayOriginToSphereCenter);\n    float dot_term = dot(ray, rayOriginToSphereCenter);\n    float someVar = dot_term * dot_term - dist * dist + radius * radius;\n    if (someVar < EPSILON) { // no intersection\n        return false;\n    }\n    t = -dot_term - sqrt(someVar);\n    return EPSILON < t && t < t_min;\n}\n\n// intersection with scene geometry\nfloat intersection(\n    const in vec3 origin\n,   const in vec3 ray\n,   out vec3 normal\n,   out vec3 color\n,   out bool reflecting)\n{\n    float t_min = INFINITY;\n    float t = INFINITY;\n\n    float colorIndex;\n\n    // intersection with triangles\n\tfor(int i = 0; i < int(NUM_TRIANGLES); ++i)\n\t{\n        vec3 triangle[3];\n        vec4 triangleIndices = indexFetch(float(i));\n\t\ttriangle[0] = vertexFetch(triangleIndices[0]);\n\t\ttriangle[1] = vertexFetch(triangleIndices[1]);\n\t\ttriangle[2] = vertexFetch(triangleIndices[2]);\n\n\t\tif(intersectionTriangle(triangle, origin, ray, t_min, t))\n\t\t{\n\t\t\tnormal = normalize(cross(\n                triangle[1] - triangle[0],\n                triangle[2] - triangle[0]\n            ));\n\t\t\tcolorIndex = triangleIndices[3];\n\t\t\tt_min = t;\n            reflecting = colorIndex == 5.0;\n\t\t}\n\t}\n\n    // intersection with sphere\n    if(intersectionSphere(SPHERE, origin, ray, t_min, t))\n    {\n        vec3 intersectionPoint = origin + ray*t;\n        normal = normalize(intersectionPoint - SPHERE.xyz);\n        colorIndex = 4.0;\n        t_min = t;\n        reflecting = true;\n    }\n\n    color = colorFetch(colorIndex);\n\n    return t_min;\n}\n\nvec3 randomPointOnHemisphere(const in int fragID)\n{\n\tfloat i = mod(float(fragID), (SPHERE_SAMPLER_SIZE[0] * SPHERE_SAMPLER_SIZE[1]));\n\n    float x = mod(i, SPHERE_SAMPLER_SIZE[0]);\n    float y = i / SPHERE_SAMPLER_SIZE[0];\n\n\treturn hsphereFetch(vec2(x,y));\n}\n\nvec3 randomPointInLight(const in int fragID)\n{\n\tfloat i = mod(float(fragID), LIGHT_SAMPLER_SIZE[0] * LIGHT_SAMPLER_SIZE[1]);\n\n    float x = mod(i, LIGHT_SAMPLER_SIZE[0]);\n    float y = i / LIGHT_SAMPLER_SIZE[0];\n\n\treturn lightFetch(vec2(x,y));\n}\n\n// intersection with scene geometry\nfloat shadow(\n\tconst in int fragID\n,\tconst in vec3 origin\n,\tconst in vec3 normal\n,   out float sqDistToLight)\n{\n    vec3 pointInLight = randomPointInLight(fragID);\n    float distToLight = distance(pointInLight, origin);\n\n\tvec3 ray_direction = normalize(pointInLight - origin);\n\n\tfloat a = dot(ray_direction, normal);\n\tif(a < EPSILON)\n\t \treturn 0.0;\n\n    vec3 v1,v2; bool r; // unused\n    float dist = intersection(origin, ray_direction, v1, v2, r);\n    if(EPSILON < dist && dist <= distToLight)\n        return 0.0;\n        \n    sqDistToLight = distToLight * distToLight;\n\treturn a;\n}\n\nmat3 computeTbn(in vec3 normal)\n{\n    vec3 arbNormal = vec3(-1.241284e-02, -7.011432e-01, +2.043006e-01);\n    arbNormal = mix(arbNormal, vec3(+2.019038e-01, +9.717299e-01, +1.223763e-01), \n        step(0.0, abs(dot(arbNormal, normal))));\n\n    vec3 e0 = cross(arbNormal, normal);\n\tvec3 e1 = cross(e0, normal);\n\n    return mat3(e0, normal, e1);\n}\n\n// http://gpupathtracer.blogspot.de/\n// http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\n// http://undernones.blogspot.de/2010/12/gpu-ray-tracing-with-glsl.html\n// http://www.iquilezles.org/www/articles/simplegpurt/simplegpurt.htm\n// http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/\n\nvoid main()\n{\n    vec3 ray_origin = u_eye;\n    vec3 ray_direction = normalize((v_ray.xyz / v_ray.w) - ray_origin);\n\n    // fragment index for random variation\n\tvec2 xy = v_uv * vec2(u_viewport[0], u_viewport[1]);\n\tint fragID = int(xy.y * u_viewport[0] + xy.x + float(u_frame) + float(u_rand));\n\n\t// path color accumulation\n\tvec3 maskColor = vec3(1.0);\n\tvec3 pathColor = vec3(0.0);\n\n    // fragment is transparent before any intersection\n    float alpha = 0.0;\n\n\tfor(int bounce = 0; bounce < BOUNCES; ++bounce)\n\t{\n        // check intersection with scene geometry\n        vec3 normal;\n        vec3 color;\n        bool reflecting;\n        float dist = intersection(ray_origin, ray_direction, normal, color, reflecting); \n\n        if(dist == INFINITY)\n            break; // TODO: break on no intersection, with correct path color weight?\n\n        // update ray for next bounce\n        ray_origin = ray_origin + ray_direction * dist;\n        if(reflecting){\n            ray_direction = reflect(ray_direction, normal);\n            if(bounce == 0) {\n                alpha = 1.0;\n            }\n            continue;\n        }\n        ray_direction = computeTbn(normal) * randomPointOnHemisphere(fragID + bounce);\n\n        // compute lighting and color\n        alpha = 1.0;\n        float squaredDistToLight = 1.0;\n  \t\tfloat lighting = shadow(fragID + bounce, ray_origin, normal, squaredDistToLight);\n  \t    maskColor *= color;\n  \t\tpathColor += maskColor * LIGHT_COLOR * lighting / squaredDistToLight;\n    }\n\n    fragColor = vec4(pow(EXPOSURE * pathColor, vec3(1.0 / GAMMA)), alpha);\n}\n\n"},42:function(n,t){n.exports="\nprecision lowp float;\n\n\n#if __VERSION__ == 100\n#else \n    #define varying out\n#endif\n\n\n\n#if __VERSION__ == 100\n    attribute vec2 a_vertex;\n#else \n    layout(location = 0) in vec2 a_vertex;\n#endif\n\n\nuniform mat4 u_transform;\nuniform mediump vec3 u_eye;\nuniform vec2 u_ndcOffset;\n\nvarying mediump vec2 v_uv;\nvarying mediump vec4 v_ray;\n\nvoid main()\n{\n    v_uv = a_vertex * 0.5 + 0.5; \n    v_ray = u_transform * vec4(u_ndcOffset + a_vertex, 1.0, 1.0);\n\n    gl_Position = vec4(a_vertex, 1.0, 1.0);\n}\n"},43:function(n,t,e){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.vertices=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,.988489,-1,-1,.976978,-1,1,1,1,-1,1,1,1,.043165,-1,-.592275,.043165,-.398688,-.592275,-.136691,-1,-.027182,-.136691,-.398688,-.027182,-.705036,-1,-.195279,-.705036,-.398688,-.195279,-.532374,-1,-.767525,-.532374,-.398688,-.767525,.521583,-1,-.116595,.521583,.202624,-.116595,.697842,-1,.452074,.697842,.202624,.452074,.129496,-1,.630901,.129496,.202624,.630901,-.046763,-1,.058655,-.046763,.202624,.058655]),t.indices=new Uint8Array([6,7,3,1,6,3,2,1,4,0,1,1,4,1,5,1,5,1,3,1,5,3,7,1,1,0,2,3,1,2,3,3,4,5,7,2,4,7,6,2,15,13,11,1,15,11,9,1,8,9,11,1,8,11,10,1,14,15,9,1,14,9,8,1,12,13,15,1,12,15,14,1,10,11,13,1,10,13,12,1,23,21,19,1,23,19,17,1,16,17,19,1,16,19,18,1,22,23,17,1,22,17,16,1,20,21,23,1,20,23,22,1,18,19,21,1,18,21,20,1]),t.colors=new Float32Array([0,0,0,.7295,.7355,.729,.611,.0555,.062,.117,.4125,.115,.062,.0555,.611])},44:function(n,t,e){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=e(0),i=e(1),o=e(43),a=i.vec3.fromValues(0,.005102,-3.86123),c=i.vec3.fromValues(0,0,0),u=i.vec3.fromValues(0,1,0),s=i.vec3.fromValues(-.233813,.98,-.188126),l=i.vec3.fromValues(.233813,.8,.187411);t.CornellRenderer=class extends r.Renderer{constructor(){super(...arguments),this._extensions=!1}onUpdate(){return this._ndcOffsetKernel=new r.AntiAliasingKernel(this._multiFrameNumber),this._navigation.update(),this._altered.any||this._camera.altered}onPrepare(){const n=this._context.gl,t=this._context.gl2facade;this._intermediateFBO.initialized||(this._colorRenderTexture.initialize(this._frameSize[0],this._frameSize[1],this._context.isWebGL2?n.RGBA8:n.RGBA,n.RGBA,n.UNSIGNED_BYTE),this._depthRenderbuffer.initialize(this._frameSize[0],this._frameSize[1],n.DEPTH_COMPONENT16),this._intermediateFBO.initialize([[t.COLOR_ATTACHMENT0,this._colorRenderTexture],[n.DEPTH_ATTACHMENT,this._depthRenderbuffer]])),this._altered.frameSize&&(this._intermediateFBO.resize(this._frameSize[0],this._frameSize[1]),this._camera.viewport=[this._frameSize[0],this._frameSize[1]]),this._altered.canvasSize&&(this._camera.aspect=this._canvasSize[0]/this._canvasSize[1]),this._altered.clearColor&&this._intermediateFBO.clearColor(this._clearColor),this._accumulate.update(),this._camera.altered&&(this._program.bind(),n.uniformMatrix4fv(this._uTransform,n.GL_FALSE,this._camera.viewProjectionInverse),n.uniform3fv(this._uEye,this._camera.eye),n.uniform4f(this._uViewport,this._camera.viewport[0],this._camera.viewport[1],1/this._camera.viewport[0],1/this._camera.viewport[1])),this._altered.reset(),this._camera.altered=!1}onFrame(n){const t=this._context.gl;t.viewport(0,0,this._frameSize[0],this._frameSize[1]),this._camera.viewport=[this._frameSize[0],this._frameSize[1]],this._intermediateFBO.bind(),this._intermediateFBO.clear(t.COLOR_BUFFER_BIT,!1,!1);const e=this._ndcOffsetKernel.get(n);e[0]=2*e[0]/this._frameSize[0],e[1]=2*e[1]/this._frameSize[1],this._program.bind(),t.uniform1i(this._uFrame,n),t.uniform1i(this._uRand,Math.floor(1e6*Math.random())),t.uniform2fv(this._uNdcOffset,e),this._hsphereImage.bind(t.TEXTURE0),this._lightsImage.bind(t.TEXTURE1),this._context.isWebGL1&&(this._verticesImage.bind(t.TEXTURE2),this._indicesImage.bind(t.TEXTURE3),this._colorsImage.bind(t.TEXTURE4)),this._ndcTriangle.bind(),this._ndcTriangle.draw(),this._ndcTriangle.unbind(),this._intermediateFBO.unbind(),this._accumulate.frame(n)}onSwap(){this._blit.framebuffer=this._accumulate.framebuffer?this._accumulate.framebuffer:this._blit.framebuffer=this._intermediateFBO,this._blit.frame()}onInitialize(n,t,i){const f=this._context.gl,h=this._context.gl2facade;!1===this._extensions&&this._context.isWebGL1&&(r.auxiliaries.assert(this._context.supportsStandardDerivatives,"expected OES_standard_derivatives support"),this._context.standardDerivatives,this._extensions=!0),this._camera=new r.Camera,this._camera.eye=a,this._camera.center=c,this._camera.up=u,this._camera.near=.1,this._camera.far=4,this._navigation=new r.Navigation(t,i),this._navigation.camera=this._camera;const d=new r.Shader(this._context,f.VERTEX_SHADER,"cornell.vert");d.initialize(e(42));const m=new r.Shader(this._context,f.FRAGMENT_SHADER,"cornell.frag");m.initialize(e(this._context.isWebGL1?this._context.supportsTextureFloat?41:40:39)),this._program=new r.Program(this._context),this._program.initialize([d,m]),this._uTransform=this._program.uniform("u_transform"),this._uFrame=this._program.uniform("u_frame"),this._uRand=this._program.uniform("u_rand"),this._uEye=this._program.uniform("u_eye"),this._uViewport=this._program.uniform("u_viewport"),this._program.bind(),f.uniform1i(this._program.uniform("u_hsphere"),0),f.uniform1i(this._program.uniform("u_lights"),1),this._program.unbind(),this._ndcTriangle=new r.NdcFillingTriangle(this._context);const _=this._program.attribute("a_vertex",0);this._ndcTriangle.initialize(_),this._hsphereImage=new r.Texture2(this._context,"hsphereImage"),this._lightsImage=new r.Texture2(this._context,"lightsImage");const v=this.pointsOnSphere(1024),g=Math.floor(Math.sqrt(v.length)),M=new Float32Array(g*g*3);for(let n=0;n<g*g;++n)M[3*n+0]=v[n][0],M[3*n+1]=v[n][1],M[3*n+2]=v[n][2];const x=this.pointsInLight(s,l,1024),p=new Float32Array(3*x.length);let I=0;for(const n of x)p[I++]=n[0],p[I++]=n[1],p[I++]=n[2];if(this._context.isWebGL1&&!this._context.supportsTextureFloat)this._hsphereImage.initialize(96,32,f.RGB,f.RGB,f.UNSIGNED_BYTE),this._hsphereImage.data(this.encodeFloatArrayAndScale(M)),this._lightsImage.initialize(96,32,f.RGB,f.RGB,f.UNSIGNED_BYTE),this._lightsImage.data(this.encodeFloatArrayAndScale(p));else{const n=r.Wizard.queryInternalTextureFormat(this._context,f.RGB,"float");this._hsphereImage.initialize(g,g,n[0],f.RGB,n[1]),this._hsphereImage.data(M),this._lightsImage.initialize(32,32,n[0],f.RGB,n[1]),this._lightsImage.data(p)}return this._hsphereImage.wrap(f.CLAMP_TO_EDGE,f.CLAMP_TO_EDGE),this._hsphereImage.filter(f.NEAREST,f.NEAREST),this._lightsImage.wrap(f.CLAMP_TO_EDGE,f.CLAMP_TO_EDGE),this._lightsImage.filter(f.NEAREST,f.NEAREST),this._context.isWebGL1&&(this._program.bind(),f.uniform1i(this._program.uniform("u_vertices"),2),f.uniform1i(this._program.uniform("u_indices"),3),f.uniform1i(this._program.uniform("u_colors"),4),this._program.unbind(),this._verticesImage=new r.Texture2(this._context,"verticesImage"),this._indicesImage=new r.Texture2(this._context,"indicesImage"),this._colorsImage=new r.Texture2(this._context,"colorsImage"),this._indicesImage.initialize(o.indices.length/4,1,f.RGBA,f.RGBA,f.UNSIGNED_BYTE),this._indicesImage.data(o.indices),n.supportsTextureFloat?(this._verticesImage.initialize(o.vertices.length/3,1,f.RGB,f.RGB,f.FLOAT),this._verticesImage.data(o.vertices),this._colorsImage.initialize(o.colors.length/3,1,f.RGB,f.RGB,f.FLOAT),this._colorsImage.data(o.colors)):(this._verticesImage.initialize(o.vertices.length/3*3,1,f.RGB,f.RGB,f.UNSIGNED_BYTE),this._verticesImage.data(this.encodeFloatArrayAndScale(o.vertices)),this._colorsImage.initialize(o.colors.length/3*3,1,f.RGB,f.RGB,f.UNSIGNED_BYTE),this._colorsImage.data(this.encodeFloatArray(o.colors))),this._verticesImage.wrap(f.CLAMP_TO_EDGE,f.CLAMP_TO_EDGE),this._verticesImage.filter(f.NEAREST,f.NEAREST),this._indicesImage.wrap(f.CLAMP_TO_EDGE,f.CLAMP_TO_EDGE),this._indicesImage.filter(f.NEAREST,f.NEAREST),this._colorsImage.wrap(f.CLAMP_TO_EDGE,f.CLAMP_TO_EDGE),this._colorsImage.filter(f.NEAREST,f.NEAREST)),this._uNdcOffset=this._program.uniform("u_ndcOffset"),this._defaultFBO=new r.DefaultFramebuffer(this._context,"DefaultFBO"),this._defaultFBO.initialize(),this._colorRenderTexture=new r.Texture2(this._context,"ColorRenderTexture"),this._depthRenderbuffer=new r.Renderbuffer(this._context,"DepthRenderbuffer"),this._intermediateFBO=new r.Framebuffer(this._context,"IntermediateFBO"),this._accumulate=new r.AccumulatePass(this._context),this._accumulate.initialize(this._ndcTriangle),this._accumulate.precision=this._framePrecision,this._accumulate.texture=this._colorRenderTexture,this._blit=new r.BlitPass(this._context),this._blit.initialize(this._ndcTriangle),this._blit.readBuffer=h.COLOR_ATTACHMENT0,this._blit.drawBuffer=f.BACK,this._blit.target=this._defaultFBO,!0}onUninitialize(){this._program.uninitialize(),this._ndcTriangle.uninitialize(),this._hsphereImage.uninitialize(),this._lightsImage.uninitialize(),this._context.isWebGL1&&(this._verticesImage.uninitialize(),this._indicesImage.uninitialize(),this._colorsImage.uninitialize()),this._intermediateFBO.uninitialize(),this._defaultFBO.uninitialize(),this._colorRenderTexture.uninitialize(),this._depthRenderbuffer.uninitialize(),this._blit.uninitialize()}shuffle(n){const t=[],e=n.slice();for(;0!==e.length;){const n=Math.floor(e.length*Math.random());t.push(e[n]),e.splice(n,1)}return t}pointsInLight(n,t,e){const o=Array(),a=i.vec3.min(i.vec3.create(),n,t),c=i.vec3.max(i.vec3.create(),n,t),u=i.vec3.subtract(i.vec3.create(),c,a),s=Math.ceil(Math.sqrt(1*e)),l=i.vec3.scale(i.vec3.create(),u,.9999/(s-1));for(let n=a[0];n<=c[0];n+=l[0])for(let t=a[2];t<=c[2];t+=l[2])o.push(i.vec3.fromValues(n,r.auxiliaries.rand(a[1],c[1]),t));return this.shuffle(o)}pointsOnSphere(n){const t=new Array(n);for(let n=0;n<t.length;++n){const e=.9999,o=r.auxiliaries.rand(-e,e),a=r.auxiliaries.rand(-e,e),c=Math.sqrt(Math.max(1-o*o-a*a,1e-4));t[n]=i.vec3.normalize(i.vec3.create(),i.vec3.fromValues(o,c,a))}return t}fract(n){return n>0?n-Math.floor(n):n-Math.ceil(n)}encode_float24x1_to_uint8x3(n,t){return n[0]=Math.floor(255*t),n[1]=Math.floor(255*this.fract(255*t)),n[2]=Math.floor(255*this.fract(65536*t)),n}encodeFloatArray(n){const t=new Uint8Array(3*n.length);for(let e=0;e<n.length;e++){const r=this.encode_float24x1_to_uint8x3(i.vec3.create(),n[e]);t[3*e+0]=r[0],t[3*e+1]=r[1],t[3*e+2]=r[2]}return t}encodeFloatArrayAndScale(n){const t=new Uint8Array(3*n.length);for(let e=0;e<n.length;e++){const r=this.encode_float24x1_to_uint8x3(i.vec3.create(),.5*n[e]+.5);t[3*e+0]=r[0],t[3*e+1]=r[1],t[3*e+2]=r[2]}return t}}},45:function(n,t,e){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=e(0),i=e(44);function o(){const n=new r.Canvas("example-canvas"),t=n.context,e=new i.CornellRenderer;n.renderer=e,n.framePrecision="float",n.frameScale=[.5,.5],n.clearColor.fromHex("d6d8db"),n.controller.multiFrameNumber=1024,n.element.addEventListener("click",()=>{n.controller.update()}),window.canvas=n,window.context=t,window.renderer=e}"complete"===window.document.readyState?o():window.onload=o},46:function(n,t,e){e(2),n.exports=e(45)}})});
//# sourceMappingURL=cornell-box.js.map